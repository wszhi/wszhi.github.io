<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Shengzhi Wang</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="靡不有初,鲜克有终">
<meta property="og:type" content="website">
<meta property="og:title" content="Shengzhi Wang">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Shengzhi Wang">
<meta property="og:description" content="靡不有初,鲜克有终">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Shengzhi Wang">
<meta name="twitter:description" content="靡不有初,鲜克有终">
  
    <link rel="alternative" href="/atom.xml" title="Shengzhi Wang" type="application/atom+xml">
  
  
    <link rel="icon" href="//favicon.png">
  
  <script src="/style.js"></script>
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="http://store.aimon.cn/Product/photo/348/2012101905747.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Shengzhi Wang</a></h1>
		</hgroup>

		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/tags/technical/">技术</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">友链</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="3" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/wszhi" title="github">github</a>
		        
					<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
		        
					<a class="rss" target="_blank" href="#" title="rss">rss</a>
		        
					<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">Shengzhi Wang</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="http://store.aimon.cn/Product/photo/348/2012101905747.jpg" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">Shengzhi Wang</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/tags/technical/">技术</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/wszhi" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        
  
    <article id="post-Go-CD-learn-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/03/Go-CD-learn-1/">Go CD 学习笔记(一)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Go CD 是属于在持续集成，持续交付过程中使用的自动化构建工具，可以执行编译，自动化测试，自动部署等等。<br>    在此之前，已经使用过Jenkins工具了，Go CD 的功能和Jenkins差不多，但又有其特点。</p>
<h3 id="Go-CD中的某些概念"><a href="#Go-CD中的某些概念" class="headerlink" title="Go CD中的某些概念"></a>Go CD中的某些概念</h3><h4 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h4><p>task是要执行的一个build任务，一般是一个命令行指令</p>
<h4 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h4><ul>
<li>一个Job由多个task组成，每个task按排列顺序执行。</li>
<li>当一个task执行失败，那么这个job就会被认为失败，并且没有其他特殊的设置的话，这个失败的task之后的其他task都不会被执行。</li>
<li>在一个job中的task作为独立的程序运行的，某一个task改变的环境变量不会影响后续的tasks，但是这个task对文件系统的更改在后续的tasks中可见。<h4 id="Stage"><a href="#Stage" class="headerlink" title="Stage"></a>Stage</h4></li>
<li>一个Stage由多个job组成，job之间可以相互独立运行，也就是说在Stage之中的job可以并行。</li>
<li>一个job失败了，那么该stage也被认为是失败的，由于stage的job相互独立，所以其他的job还是会继续执行，不受影响。<h4 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h4>一个Pipeline由多个stage组成，stage按顺序执行，若是一个stage执行失败了，那么该pipeline也被认为是失败的，并且之后的stage不会继续执行。<h4 id="Materials"><a href="#Materials" class="headerlink" title="Materials"></a>Materials</h4></li>
<li>Materials是pipeline跑的起因，一般是源代码仓库，例如git、SVN等。</li>
<li>当代码更新的时候，Go Server会持续的获取代码仓库的代码。</li>
<li>在某一个pipeline1中的stage也可以作为另一个pipeline2的Materials，如此在stage执行完毕后会触发pipeline2运行。<h4 id="Artifacts"><a href="#Artifacts" class="headerlink" title="Artifacts"></a>Artifacts</h4>  Artifacts一般是文件或者文件夹，当job执行完毕后会发布Artifacts，供给用户、后续执行的stage或pipeline使用。<h4 id="Agent"><a href="#Agent" class="headerlink" title="Agent"></a>Agent</h4>  Go Agents是tasks, jobs, stages 和 pipeline 运行的地方。<h4 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h4>  Resources指的是Agent中有的资源，它帮助jobs寻找适合的Agent，当job需要的资源在某agent中都存在的时候，才会使用该agent。<h4 id="Environments"><a href="#Environments" class="headerlink" title="Environments"></a>Environments</h4></li>
<li>Environments是用来分组的，把有联系agent 和 pipelines分成一组。</li>
<li>一个pipeline最多只能在一个environment中。</li>
<li>一个agent可以在多个environment中，或不属于任何一个environment。</li>
<li>一个agent只能获取到属于和该agent有联系的environment中的pipeline中的jobs；无法获取其他jobs，哪怕这些jobs不属于任何environment。<h4 id="Environment-Variables"><a href="#Environment-Variables" class="headerlink" title="Environment Variables"></a>Environment Variables</h4></li>
<li>Environment Variables和Environments没有关系，它是用户在配置中自己定义的变量。这些环境变量与Task在运行时可用的其他环境变量一样。</li>
<li>Environment Variables可以在 Environment ，pipelines，stages 和 jobs 中定义。并且下一层的Environment Variables可以重写上一层的，例如jobs重写Environment的变量。</li>
</ul>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/07/03/Go-CD-learn-1/" class="archive-article-date">
  	<time datetime="2017-07-03T03:10:56.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-07-03</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/pipeline/">pipeline</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/technical/">technical</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-java-generate-pdf" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/03/java-generate-pdf/">java 生成 pdf</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在日常开发过程中，若是想要把java中的某个对象中的内容，按某种排列方式输出到PDF中，有几种方式，此处只使用了itextpdf的方式。<br><a href="http://developers.itextpdf.com/content/itext-5-examples" target="_blank" rel="external">itext pdf 文档</a></p>
<h4 id="一、加入依赖"><a href="#一、加入依赖" class="headerlink" title="一、加入依赖"></a>一、加入依赖</h4><p>在gradle中只需要加入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">compile group: &apos;com.itextpdf&apos;, name: &apos;itextpdf&apos;, version: &apos;5.5.6&apos;</div></pre></td></tr></table></figure></p>
<h4 id="二、创建一个Document，并加入内容"><a href="#二、创建一个Document，并加入内容" class="headerlink" title="二、创建一个Document，并加入内容"></a>二、创建一个Document，并加入内容</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public void createPdf() &#123;</div><div class="line">        Document document = new Document();</div><div class="line">        try &#123;</div><div class="line">            PdfWriter writer = PdfWriter.getInstance(document, new FileOutputStream(&quot;HelloWorld.pdf&quot;));</div><div class="line">            document.open();</div><div class="line">            document.add(new Paragraph(&quot;Some content here&quot;));</div><div class="line">            settings(document);            </div><div class="line">            style(document);</div><div class="line">            document.close();</div><div class="line">            writer.close();</div><div class="line">        &#125; catch (FileNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; catch (DocumentException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>新建一个Document对象，再定义PdfWriter，把document中的内容写入HelloWorld.pdf文件。<br>在添加内容到document之前需要执行document.open()才可以。<br>document可以添加Paragraph、<a href="http://developers.itextpdf.com/examples/itext-action-second-edition/chapter-4" target="_blank" rel="external">PdfPTable</a>等元素。</p>
<h4 id="三、踩过的坑"><a href="#三、踩过的坑" class="headerlink" title="三、踩过的坑"></a>三、踩过的坑</h4><ul>
<li>问题：使用PdfPTable来构造整体结构时，如何设置行间距？<br>解决方案：在给cell中添加内容的时候有两种方式，一种是直接初始化的时候添加，另一种是调用addElement方法添加内容。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PdfPCell cell = new PdfPCell(new Paragraph(100,&quot;Table 1&quot;));</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PdfPCell cell= new PdfPCell();</div><div class="line">cell.addElement(new Paragraph(100,&quot;Table 1&quot;));</div></pre></td></tr></table></figure>
<p>这两种方法中第一种不支持设置Leading为100，第二种方法支持设置Leading为100。除了在初始化Paragraph时可以设置Leading，还可以调用setLeading()来设置，第一个参数是固定的行间距，第二个参数是行间距为行高的倍数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Paragraph element = new Paragraph(&quot;Some content here&quot;);</div><div class="line">element.setLeading(0,2);</div></pre></td></tr></table></figure></p>
<ul>
<li><p>问题：如何给PdfPTable设置每列的宽度？<br>解决方案：设置table的列宽时，需要把所有列的宽度放进数组列表中，缺一不可，如果数组的大小和table的列数不匹配则整体都不会显示出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PdfPTable table = new PdfPTable(3);</div><div class="line">table.setWidths(new int[]&#123;2, 1, 1&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>问题：如何设置边框？<br>解决方案：边框的值不一样，当setBorder()函数的参数为0时，没有边框，1为上边框TOP，2为下边框BOTTOM，4为左边框LEFT，8为右边框RIGHT。具体的可以调用Rectangle中的固定值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PdfPCell cell = new PdfPCell(new Phrase(&quot;StackOverflow&quot;));</div><div class="line">cell.setBorder(Rectangle.NO_BORDER);</div></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/07/03/java-generate-pdf/" class="archive-article-date">
  	<time datetime="2017-07-03T03:08:47.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-07-03</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/technical/">technical</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-java-download-pdf" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/03/java-download-pdf/">Java 下载 pdf</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在实际应用中有这么一个场景，用户希望在页面上有一个下载按钮，点击按钮时把当前页的内容生产一个PDF文件下载下来。</p>
<p>这个需求有两种表现形式，一种是当用户点击按钮时直接在浏览器中弹出保存框下载PDF文件，另一种是返回PDF的视图，在浏览器中预览PDF文件的内容，然后再下载。</p>
<p>这里分别介绍两种实现方式：</p>
<h4 id="一、直接下载PDF文件"><a href="#一、直接下载PDF文件" class="headerlink" title="一、直接下载PDF文件"></a>一、直接下载PDF文件</h4><p>本质上来说，把PDF文件读取到inputStream中，继而放入返回的的实体中。<br>返回的ResponseEntity中，注意指定Content-Type的内容为application/pdf，<br>且Content-Disposition的内容为attachment; filename=”helloWorld.pdf”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@RequestMapping(value = &quot;/pdfDownload&quot;, method = GET)</div><div class="line">    public ResponseEntity download() throws IOException &#123;</div><div class="line">        File file = new File(&quot;HelloWorld.pdf&quot;);</div><div class="line">        InputStream in = new FileInputStream(file);</div><div class="line">        final HttpHeaders headers = new HttpHeaders();</div><div class="line">        headers.add(&quot;Content-Type&quot;, &quot;application/pdf&quot;);</div><div class="line">        headers.add(&quot;Content-Disposition&quot;, &quot;attachment; filename=&quot; + file.getName() );</div><div class="line">        return new ResponseEntity&lt;&gt;(IOUtils.toByteArray(in), headers, HttpStatus.OK);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>该方法在浏览器中直接访问localhost:8080/pdfDownload就回弹出一个文件保存框，选择保存的本地路径即可下载，或者有的效果是直接在浏览器中下载了PDF文件，这是因为所使用的浏览器本身的下载设置，可以根据个人喜好来设置究竟弹出还是不弹出保存框。</p>
<h4 id="二、浏览器预览PDF文件，再下载"><a href="#二、浏览器预览PDF文件，再下载" class="headerlink" title="二、浏览器预览PDF文件，再下载"></a>二、浏览器预览PDF文件，再下载</h4><p>如果使用的不是RestController，就可以直接返回一个String字符串，内容为PDF文件的视图名称，这里定义为helloWorldPDF，该视图名在views.properties中配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@RequestMapping(value = &quot;/pdfDownload2&quot;, method = GET)</div><div class="line">    public String download2(HttpServletRequest request) throws IOException &#123;</div><div class="line">        return &quot;helloWorldPDF&quot;;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>resource资源文件夹中的views.properties文件的内容为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">helloWorldPDF.(class)=com.test.report.PDFView</div></pre></td></tr></table></figure></p>
<p>这里的com.test.report.PDFView指的是定义的PDF视图的内容。<br>我们使用了itextpdf的jar包来生成PDF文件的内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">compile group: &apos;com.itextpdf&apos;, name: &apos;itextpdf&apos;, version: &apos;5.5.6&apos;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class PDFView extends AbstractView &#123;</div><div class="line">    public PDFView() &#123;</div><div class="line">        setContentType(&quot;application/pdf&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected boolean generatesDownloadContent() &#123;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected final void renderMergedOutputModel(Map&lt;String, Object&gt; model,</div><div class="line">                                                 HttpServletRequest request, HttpServletResponse response)</div><div class="line">            throws Exception &#123;</div><div class="line">        ByteArrayOutputStream baos = createTemporaryOutputStream();</div><div class="line">        Document document = new Document(PageSize.A4);</div><div class="line">        PdfWriter writer = PdfWriter.getInstance(document, baos);</div><div class="line">        writer.setViewerPreferences(PdfWriter.ALLOW_PRINTING | PdfWriter.PageLayoutSinglePage);</div><div class="line">        document.open();</div><div class="line">        Paragraph header = new Paragraph(new Chunk(&quot;hello world&quot;));</div><div class="line">        document.add(header);</div><div class="line">        document.close();</div><div class="line">        writeToResponse(response, baos);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上就生成了我们需要的PDF文件的内容，并放进ByteArrayOutputStream中，调用writeToResponse方法把字节流传进response中。</p>
<p>因为使用的是SpringBootApplication，所以需要加的一些配置是在 Application 的包含main方法的class中进行的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@Bean</div><div class="line">    public ResourceBundleViewResolver viewResolver() &#123;</div><div class="line">        ResourceBundleViewResolver resolver = new ResourceBundleViewResolver();</div><div class="line">        resolver.setOrder(1);</div><div class="line">        resolver.setBasename(&quot;views&quot;);</div><div class="line">        return resolver;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>如此一来就可以直接在浏览器中访问localhost:8080/pdfDownload2看到PDF文件的预览页面，在页面中可以进行下载，打印等操作。</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/07/03/java-download-pdf/" class="archive-article-date">
  	<time datetime="2017-07-03T03:07:52.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-07-03</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/technical/">technical</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-Angular2-Learn-note-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/03/Angular2-Learn-note-1/">Angular2 Learn note(1)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>推荐<a href="https://angular.io/docs/ts/latest/guide/learning-angular.html" target="_blank" rel="external">官方学习文档</a></p>
<h4 id="安装开发环境"><a href="#安装开发环境" class="headerlink" title="安装开发环境"></a>安装开发环境</h4><p>新建一个文件夹simpleExample，创建一个文件名为tsconfig.json的文件，内容为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;compilerOptions&quot;: &#123;</div><div class="line">    &quot;target&quot;: &quot;es5&quot;,</div><div class="line">    &quot;module&quot;: &quot;system&quot;,</div><div class="line">    &quot;moduleResolution&quot;: &quot;node&quot;,</div><div class="line">    &quot;sourceMap&quot;: true,</div><div class="line">    &quot;emitDecoratorMetadata&quot;: true,</div><div class="line">    &quot;experimentalDecorators&quot;: true,</div><div class="line">    &quot;removeComments&quot;: false,</div><div class="line">    &quot;noImplicitAny&quot;: false</div><div class="line">  &#125;,</div><div class="line">  &quot;exclude&quot;: [</div><div class="line">    &quot;node_modules&quot;,</div><div class="line">    &quot;typings/main&quot;,</div><div class="line">    &quot;typings/main.d.ts&quot;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>创建一个文件名为typings.json的文件，内容为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;globalDependencies&quot;: &#123;</div><div class="line">    &quot;core-js&quot;: &quot;registry:dt/core-js#0.0.0+20160602141332&quot;,</div><div class="line">    &quot;jasmine&quot;: &quot;registry:dt/jasmine#2.2.0+20160621224255&quot;,</div><div class="line">    &quot;node&quot;: &quot;registry:dt/node#6.0.0+20160621231320&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>创建一个文件名为package.json的文件，该文件中包含了我们应用所需要用到的packages，文件内容为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;name&quot;: &quot;angular2-demo&quot;,</div><div class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</div><div class="line">  &quot;scripts&quot;: &#123;</div><div class="line">    &quot;start&quot;: &quot;concurrent \&quot;npm run tsc:w\&quot; \&quot;npm run lite\&quot; &quot;,</div><div class="line">    &quot;tsc&quot;: &quot;tsc&quot;,</div><div class="line">    &quot;tsc:w&quot;: &quot;tsc -w&quot;,</div><div class="line">    &quot;lite&quot;: &quot;lite-server&quot;,</div><div class="line">    &quot;typings&quot;: &quot;typings&quot;,</div><div class="line">    &quot;postinstall&quot;: &quot;typings install&quot;</div><div class="line">  &#125;,</div><div class="line">  &quot;license&quot;: &quot;ISC&quot;,</div><div class="line">  &quot;dependencies&quot;: &#123;</div><div class="line">    &quot;angular2&quot;: &quot;2.0.0-beta.7&quot;,</div><div class="line">    &quot;systemjs&quot;: &quot;0.19.22&quot;,</div><div class="line">    &quot;es6-promise&quot;: &quot;^3.0.2&quot;,</div><div class="line">    &quot;es6-shim&quot;: &quot;^0.33.3&quot;,</div><div class="line">    &quot;reflect-metadata&quot;: &quot;0.1.2&quot;,</div><div class="line">    &quot;rxjs&quot;: &quot;5.0.0-beta.2&quot;,</div><div class="line">    &quot;zone.js&quot;: &quot;0.5.15&quot;</div><div class="line">  &#125;,</div><div class="line">  &quot;devDependencies&quot;: &#123;</div><div class="line">    &quot;concurrently&quot;: &quot;^2.0.0&quot;,</div><div class="line">    &quot;lite-server&quot;: &quot;^2.1.0&quot;,</div><div class="line">    &quot;typescript&quot;: &quot;^1.7.5&quot;,</div><div class="line">    &quot;typings&quot;:&quot;^0.6.8&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>执行npm install 可以下载以上的依赖包</p>
<h4 id="开始第一个angular-2-程序"><a href="#开始第一个angular-2-程序" class="headerlink" title="开始第一个angular 2 程序"></a>开始第一个angular 2 程序</h4><p>新建文件夹名为app，在该文件目录下新建hello_world_main.ts<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">import &#123;bootstrap&#125; from &quot;angular2/platform/browser&quot;</div><div class="line">import &#123;MyHelloWorldClass&#125; from &quot;./hello_world_app.component&quot;</div><div class="line"></div><div class="line">bootstrap(MyHelloWorldClass);</div></pre></td></tr></table></figure></p>
<p>同样目录下新建hello_world_app.component.ts<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">import &#123;Component, View&#125; from &quot;angular2/core&quot;;</div><div class="line"></div><div class="line">@Component(&#123;</div><div class="line">   selector: &apos;my-app&apos;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">@View(&#123;</div><div class="line">  template: &apos;&lt;h2&gt;Hello World !!&lt;/h2&gt;&apos;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">export class MyHelloWorldClass &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>回到上一层目录新建index.html<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">  &lt;head&gt;</div><div class="line">    &lt;title&gt;Hello World&lt;/title&gt;</div><div class="line">    &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/es6-shim/0.33.3/es6-shim.min.js&quot;&gt;&lt;/script&gt;</div><div class="line">    &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/systemjs/0.19.20/system-polyfills.js&quot;&gt;&lt;/script&gt;</div><div class="line">    &lt;script src=&quot;https://code.angularjs.org/2.0.0-beta.6/angular2-polyfills.js&quot;&gt;&lt;/script&gt;</div><div class="line">    &lt;script src=&quot;https://code.angularjs.org/tools/system.js&quot;&gt;&lt;/script&gt;</div><div class="line">    &lt;script src=&quot;https://code.angularjs.org/tools/typescript.js&quot;&gt;&lt;/script&gt;</div><div class="line">    &lt;script src=&quot;https://code.angularjs.org/2.0.0-beta.6/Rx.js&quot;&gt;&lt;/script&gt;</div><div class="line">    &lt;script src=&quot;https://code.angularjs.org/2.0.0-beta.6/angular2.dev.js&quot;&gt;&lt;/script&gt;</div><div class="line">    &lt;script&gt;</div><div class="line">      System.config(&#123;</div><div class="line">        transpiler: &apos;typescript&apos;,</div><div class="line">        typescriptOptions: &#123; emitDecoratorMetadata: true &#125;,</div><div class="line">        packages: &#123;&apos;app&apos;: &#123;defaultExtension: &apos;ts&apos;&#125;&#125;,</div><div class="line">        map: &#123; &apos;app&apos;: &apos;app&apos; &#125;</div><div class="line">      &#125;);</div><div class="line">      System.import(&apos;app/hello_world_main&apos;)</div><div class="line">            .then(null, console.error.bind(console));</div><div class="line">    &lt;/script&gt;</div><div class="line">  &lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">   &lt;my-app&gt;Loading...&lt;/my-app&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>index.html中使用SystemJS加载所需的模块，通过System.config函数配置。<br>配置详情为：<br>packages 告知System loader当没有文件名或者没有后缀的时候如何加载文件<br>map 告知System loader在何处加载所需的文件,此处app(左边)指向的是名为app(右边)的目录，所以在import的时候可以找到在app目录下的hello_world_main.ts 文件。</p>
<p>参考文章<br><a href="http://www.jianshu.com/p/db4be331b026" target="_blank" rel="external">Angular2 – SystemJS解析</a><br><a href="https://www.tutorialspoint.com/angular2/angular2_hello_world.htm" target="_blank" rel="external">tutorialspoint 网站</a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/07/03/Angular2-Learn-note-1/" class="archive-article-date">
  	<time datetime="2017-07-03T03:06:20.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-07-03</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Angular/">Angular</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/technical/">technical</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-text-editor-tinymce" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/03/text-editor-tinymce/">text editor(tinymce)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近需要在 react 代码中插入一个文本编辑器，然后看了一下tinymce这个库。</p>
<h3 id="导入库"><a href="#导入库" class="headerlink" title="导入库"></a>导入库</h3><p>在<a href="https://www.npmjs.com/search?q=tinymce" target="_blank" rel="external">npm中搜索相关的库</a>，然后发现有直接包装好的<a href="https://www.npmjs.com/package/react-tinymce" target="_blank" rel="external">react-tinymce</a>库，但是在引用过程中会出现 “Unknown prop <code>config</code> on <tinymce> tag” 的错误提示。所以就放弃了直接引用这个库转而使用<a href="https://www.tinymce.com/" target="_blank" rel="external">tinymce</a>。</tinymce></p>
<p>导入tinymce,可以参考<a href="https://www.tinymce.com/download/" target="_blank" rel="external">官方网站</a>，有多种导入的方式。<br>这里选用了在js中直接引入库的方式。<br>把下面的代码插入到HTML中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script src=&quot;//tinymce.cachefly.net/4.3/tinymce.min.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>在react js 代码中加入以下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">componentDidMount()&#123;</div><div class="line">    tinymce.init(&#123;</div><div class="line">      selector: &quot;textarea.tinymce-editor&quot;,</div><div class="line">      theme: &quot;modern&quot;,</div><div class="line">      skin_url: &apos;//cdnjs.cloudflare.com/ajax/libs/tinymce/4.3.5/skins/lightgray/&apos;,</div><div class="line">      height: 150,</div><div class="line">      resize: &quot;both&quot;,</div><div class="line">      content_css: [&quot;//nuance.jiveon.com/resources/statics/30387/nuance_simplified.css&quot;, &quot;//nuance.jiveon.com/resources/statics/30387/nuance_bootstrap_combined.css&quot;],</div><div class="line">      plugins: [</div><div class="line">        &apos;advlist autolink lists link image charmap print preview hr anchor pagebreak&apos;,</div><div class="line">        &apos;searchreplace wordcount visualblocks visualchars code fullscreen&apos;,</div><div class="line">        &apos;insertdatetime media nonbreaking save table contextmenu directionality&apos;,</div><div class="line">        &apos;emoticons template paste textcolor colorpicker textpattern imagetools&apos;</div><div class="line">      ],</div><div class="line">      toolbar1: &apos;undo redo | styleselect | bold italic | alignleft aligncenter alignright alignjustify | bullist numlist outdent indent | link image&apos;,</div><div class="line">      toolbar2: &apos;forecolor backcolor emoticons&apos;,</div><div class="line">      image_advtab: true</div><div class="line">    &#125;);</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>在对应的HTML中加入以下代码，然后就生效了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;textarea className=&quot;tinymce-editor&quot;&gt;&lt;/textarea&gt;</div></pre></td></tr></table></figure></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/07/03/text-editor-tinymce/" class="archive-article-date">
  	<time datetime="2017-07-03T03:04:05.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-07-03</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/technical/">technical</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-Docker-learn3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/28/Docker-learn3/">Docker 学习笔记(三)--创建image</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="build-构建一个镜像"><a href="#build-构建一个镜像" class="headerlink" title="build 构建一个镜像"></a>build 构建一个镜像</h2><p>读取配置文件构建image(文件名默认Dockerfile,也可以自定义):<br>1)”-“表示将从STDIN读入数据,即将Dockerfile中的数据通过STDIN传入build中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Docker build - &lt; Dockerfile</div></pre></td></tr></table></figure></p>
<p>2)PATH参数表示Dockerfile全路径,即将Dockerfile放置到$(HOME)/Users目录下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Docker build $(HOME)/Users/Dockerfile</div><div class="line">Docker build $(HOME)/Users/otherfile    名字可变</div></pre></td></tr></table></figure></p>
<p>3)使用URL参数,URL必须指向一个git地址。Docker会把指定的git仓库克隆到本地,然后把仓库中的Dockerfile内容传给Docker Daemon。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Docker build https://github.com/wszhi/Docker-image.git#container:Docker</div></pre></td></tr></table></figure></p>
<p>以上命令通知Docker Daemon加载<a href="https://github.com/wszhi/Docker-image.git" target="_blank" rel="external">https://github.com/wszhi/Docker-image.git</a> 仓库,切换到container分支,在Docker目录下的Dockerfile文件来构建image。<br>注意: “:”后面的是Dockerfile文件的路径,此方式不支持自定义命名。若为master分支#后为空<br>若当前目录有Dockerfile文件可以省略路径使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Docker build --rm=false .</div></pre></td></tr></table></figure></p>
<p>–rm=false表示不删除临时镜像,当经常构建且变化不大的时候建议使用。</p>
<h4 id="build-构建镜像三要素"><a href="#build-构建镜像三要素" class="headerlink" title="build 构建镜像三要素"></a>build 构建镜像三要素</h4><p>build命令构建镜像是用Dockerfile文件中的指令来构建的,三个要素为:Dockerfile文件、所涉及文件和镜像参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Docker build -t image_name .</div></pre></td></tr></table></figure></p>
<p>默认执行Dockerfile文件。</p>
<h4 id="build命令执行的主要逻辑"><a href="#build命令执行的主要逻辑" class="headerlink" title="build命令执行的主要逻辑"></a>build命令执行的主要逻辑</h4><p>1)获取Dockerfile文件——客户端<br>2)加载Dockerfile文件所在目录下的所有文件——-客户端<br>3)解析Dockerfile文件指令<br>4)执行文件内指令,判断是否存在有效缓存镜像<br>5)执行指令</p>
<p>其中获取Dockerfile文件的方式有三种:<br>1.通过标准输入传入,参数”-“;<br>2.通过远程方式获取,git;<br>3.通过指定路径方式获取。</p>
<h4 id="build命令构建镜像原理"><a href="#build命令构建镜像原理" class="headerlink" title="build命令构建镜像原理"></a>build命令构建镜像原理</h4><p>客户端将Dockerfile所需要的文件和镜像参数传递给Daemon。<br>然后Daemon处理客户端传来的各项参数(为后续的解压操作和文件I/O操作做准备)。<br>当参数处理完成之后,Daemon开始解压文件,抽取文件。<br>最后Daemon解析Dockerfile,生成指令语法树。<br>之后Daemon使用解析后的指令从已经初始化的指令——函数对应表中找到对应的处理函数,最后执行函数。</p>
<p>流程:<br>(客户端)<br>加载Dockerfile—&gt;压缩构建目录—&gt;添加镜像参数——发送构建请求—-&gt;<br>(服务端)<br>—-&gt;生成构建参数—&gt;获取压缩包—&gt;解压文件—&gt;解析Dockerfile生成语法树—&gt;初始化指令处理对照表—&gt;循环执行指令—&gt;删除解压文件—&gt;构建完成</p>
<h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>Dockerfile 文件记录着用户”创建”镜像过程中需要执行的所有命令,Docker可以读懂的脚本文件。<br>镜像指的是一组特定的文件层,镜像的构建过程就是Docker执行Dockerfile所定义命令而形成这组文件层的过程。</p>
<h4 id="Dockerfile-内置命令"><a href="#Dockerfile-内置命令" class="headerlink" title="Dockerfile 内置命令"></a>Dockerfile 内置命令</h4><p><strong>FROM 指明基础镜像名称,必填</strong></p>
<pre><code>FROM &lt;image&gt;
FROM &lt;image&gt;:&lt;tag&gt;
FROM &lt;iamge&gt;@&lt;digest&gt;
</code></pre><p>当同时构建多个image时,可以出现多次FROM,但是只会返回最后一个镜像的ID,前几个会被标记为<none>:<none></none></none></p>
<p><strong>MAINTAINER 备注信息,包括作者、版本等,可选填</strong></p>
<pre><code>MAINTAINER 作者
</code></pre><p><strong>RUN 用于执行后面的命令,当RUN执行完毕后,将产生一个新的文件层,可选填</strong></p>
<pre><code># 当镜像中有/bin/sh
RUN &lt;command&gt;
# 当镜像中没有/bin/sh,使用以下方案,可以执行基础镜像中任意一个二进制程序,注意只能用双引号
RUN [&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;echo hello&quot;]
</code></pre><p>镜像最多只能保存126个文件层,包括基础镜像的文件层;执行一次RUN就会产生一个文件层。</p>
<p><strong>CMD 指定此镜像启动时默认执行命令,可选填</strong></p>
<pre><code>#推荐用法,其设定的命令将作为容器启动时的默认执行命令
CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]
#param 将作为ENTERPOINT的默认参数使用
CMD [&quot;param1&quot;,&quot;param2&quot;]
#将后面的命令作为shell命令,依靠/bin/sh -C 来执行
CMD command param1 param2
example: CMD echo &quot;This is a test&quot; | wc -
</code></pre><p>一个Dockerfile可以有多个CMD命令,可是只有最后一个CMD命令生效,CMD中也只能出现双引号,如果使用环境变量使用sh -C。</p>
<p><strong>LABEL 在镜像中添加元数据。例如版本号、构建日期等,可选填</strong></p>
<pre><code>LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...
</code></pre><p>使用键值对的形式来向镜像文件中添加元数据的命令<br>如果键值对中存在空格,则需要使用双引号来回避错误<br>一个LABEL命令也会产生新的文件层</p>
<pre><code>LABEL &quot;description&quot;=&quot;just for test&quot; &quot;version&quot;=&quot;1.0&quot;
</code></pre><p><strong>EXPOSE 指定需要暴露的网络端口号,可选填</strong></p>
<pre><code>EXPOSE 8080
CMD [&quot;catalina.sh&quot;,&quot;run&quot;]
</code></pre><p>当容器运行时,来通知Docker这个容器中哪些端口是应用程序用来监听的,这些端口不会被外部网络访问到,只能被主机的其他容器访问。</p>
<p><strong>ENV 在镜像中添加环境变量,可选填</strong></p>
<pre><code># 第一个字符为key,后面所有字符为value
ENV &lt;key&gt; &lt;value&gt;
左边为key,右边为value,value有空格时,需要&quot;\&quot;转义或者使用双引号
ENV &lt;key&gt;=&lt;value&gt; ....
</code></pre><p><strong>ADD 向镜像添加新文件或者新目录,可选填</strong><br>将src标记的文件,添加到容器中的dest所标记的路径中去。src标记的文件可以是本地文件,可以是本地目录,甚至可以是URL链接。<br>src标记的是本地文件或者目录时,其相对路径应该是相对于Dockerfile所在目录的路径,而dest则应该指向容器中的目录。如果这个目录不存在,当ADD命令执行时,将会在容器中自动创建此目录。<br>在src标记的路径中,允许使用通配符。而dest路径不能使用通配符,必须是绝对路径,或者相对于WORKDIR的相对路径。</p>
<pre><code>#添加所有以hom开头的文件
ADD hom* /mydir/
# ? 号可以被任意单个字符所代替
ADD hom?.txt /mydir/
</code></pre><p>规则:<br> 1.src指定路径必须存在于Dockerfile所在目录。因为在Dockerfile执行时,Docker daemon会读取Dockerfile所在目录的所有数据。如果ADD命令使用的文件在此目录中不存在,那么daemon将找不到指定文件。<br> 2.如果src指定的是URL,并且dest所指定的路径没有以”/“结尾,那么URL下载的数据将直接覆盖dest所给定的文件。<br> 3.如果src指定的是URL,并且dest所指定的路径以”/“结尾,那么URL下载后的数据将直接写入dest所指定的目录中。<br> 4.如果src指向一个目录,那么ADD指令将包括元数据在内的所有数据复制到容器中dest指定的文件中,但src所指定的目录本身不会被复制进去,只会复制此目录下的文件。<br> 5.如果src指向的是一个已知格式的压缩文件。当添加到容器之后会自动执行解压缩动作。从而从URL中下载的压缩文件则不会执行解压缩。<br> 6.如果src使用通配符指定了多个文件,那么此时dest必须是一个以”/“结尾的目录。<br> 7.如果dest指向的路径没有以”/“结尾,那么这个路径指向的文件将会被src指定的文件覆盖。<br> 8.如果dest指向的路径不存在,那么此路径中所涉及的父级目录都将会被创建。<br> 9.当src指向的URL没有下载权限时,首先需要使用RUN wget或者RUN curl获取文件。<br> 10.当ADD命令所标记的文件发生变化时,从变化的那个ADD命令开始,保存在缓存中的镜像将会实效,同时RUN命令产生的镜像也会失效。<br><strong>COPY 从主句镜像复制文件,可选填</strong><br>向容器中指定的路径下添加文件。</p>
<pre><code>#添加所有以hom开头的文件
COPY hom* /mydir/
# ? 号可以被任意单个字符所代替
COPY hom?.txt /mydir/    
</code></pre><p>1-1<br>2-4<br>3-6<br>4-7<br>5-8<br>6如果使用STDIN输入Dockerfile内容,那么Docker命令将会失效。</p>
<p><strong>ENTRYPOINT 在镜像中设定默认执行的二进制程序,可选填</strong><br>ENTRYPOINT用来设定容器运行时默认执行程序的命令。</p>
<pre><code>#第一种,推荐使用,可以自行设定需要执行的二进制程序和参数。
ENTRYPOINT [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] 
#第二种,将所设定的二进制程序限制在/bin/sh -C 下执行。
ENTRYPOINT command param1 param2
</code></pre><p>ENTRYPOINT可以出现多次,只有最后一次起作用。<br>CMD指定的值将作为参数附加到ENTRYPOINT里的命令之后。如果run命令后面添加了其他参数,此时的CMD指定的参数将会失效。<br>第二种用法,ENTRYPOINT 命令设定的二进制程序将会忽略所有来自于CMD和RUN命令后面所添加的所有参数,只会运行ENTRYPOINT命令所设定的二进制程序。<br>为了确保容器可以正确处理stop命令发来的SIG信号,Docker建议使用exec来启动二进制程序。</p>
<p><strong>VOLUME 向镜像挂载一个卷组,可选填</strong></p>
<pre><code>VOLUME [&quot;/data&quot;]
</code></pre><p>VOLUME可以在容器内部创建一个指定名称的挂载点。<br>如果以及在Dockerfile里声明了某个挂载点,那么以后对此挂载点种文件的操作将不会生效。一般在Dockerfile结尾处声明挂载点。</p>
<pre><code>FROM nginx
COPY content /usr/share/nginx/html
COPY conf /etc/nginx
VOLUME /usr/share/nginx/html
VOLUME /etc/nginx
</code></pre><p>构建镜像</p>
<pre><code>Docker build -t mynginximage .
</code></pre><p>创建容器</p>
<pre><code>Docker run --name mynginx -P -d mynginximage
Docker run -it --volumes-from mynginx --name mynginxfiles debian /bin/bash
</code></pre><p>–volumes-from,从mynginx继承了配置文件信息,此时在mynginxfiles当中只能看到继承文件的信息而无法看到其他文件。在这个容器中可以任意编写配置文件而不会影响其他文件和容器。<br><strong>USER 在镜像构建过程中,生成或者切换到另外一个用户,可选填</strong></p>
<pre><code>USER daemon
</code></pre><p>切换用户身份,当执行完USER命令后,其后面所有的命令都将以新用户的身份来执行。</p>
<p><strong>WORKDITR 设定此镜像后续操作的默认工作目录,可选填</strong></p>
<pre><code>WORKDIR /path/to/workdir
</code></pre><p>WORKDIR是用来切换当前工作目录的指令。切换后的路径影响后续的指令中的路径。<br>WORKDIR可以在Dockerfile出现多次,但最终生效的路径是所有WORKDIR指定的路径的叠加。<br>如果需要切换到其他的工作目录,那么应该使用全路径进行切换。如果使用相对路径,默认在当前目录中切换。<br>在WORKDIR中只可以使用ENV设定的环境变量值</p>
<pre><code>ENV DIRPATH /path
WORKDIR $DIRPATH/$DIRNAME
</code></pre><p>结果为/path/$DIRNAME</p>
<p><strong>ONBUILD 配置构建触发指令集,可选填</strong><br>由ONBUILD创建的触发命令集在当前Dockerfile执行过程中不会执行,而当此镜像被其他镜像当作其他镜像当作基础镜像使用时,将会被执行。</p>
<p>Dockerfile1</p>
<pre><code>FROM tomcat:7.0.72-jre7
MAINTAINER WSZ
ADD build_image_share /build_image_share
RUN [&quot;chmod&quot;,&quot;+x&quot;, &quot;/build_image_share&quot;]

LABEL &quot;description&quot;=&quot;just for test&quot; &quot;version&quot;=&quot;1.0&quot;
ENV myName=&quot;Shengzhi Wang&quot; mySoft=&quot;Docker image build&quot;


RUN mkdir /myvolume
RUN echo &quot;hello world&quot; &gt; /myvolume/greeting
VOLUME /myvolume

CMD echo &quot;This is a test&quot; | wc -
EXPOSE 8080
CMD［&quot;catalina.sh&quot;,&quot;run&quot;］
</code></pre><p>Dockerfile2</p>
<pre><code>FROM tomcat:7.0.72-jre7
MAINTAINER WSZ

ADD build_image_share /build_image_share
RUN [&quot;chmod&quot;,&quot;+x&quot;, &quot;/build_image_share&quot;]

WORKDIR /usr/local/tomcat/webapps
RUN rm -rf ROOT
WORKDIR /usr/local/tomcat/conf/Catalina/localhost
RUN echo &quot;&lt;?xml version=&apos;1.0&apos; encoding=&apos;utf-8&apos;?&gt;&quot; &gt; ROOT.xml 
RUN echo &quot;&lt;Context path=&apos;/show_books&apos; docBase=&apos;/build_image_share/show_books_base_on_angularJS_Underscore_master&apos; debug=&apos;0&apos; privileged=&apos;true&apos; reloadable=&apos;true&apos;/&gt; &quot; &gt;&gt; ROOT.xml
# RUN echo &quot;&lt;Context path=&apos;/shoppingweb&apos; docBase=&apos;/build_image_share/shoppingweb&apos; debug=&apos;0&apos; privileged=&apos;true&apos; reloadable=&apos;true&apos;/&gt; &quot; &gt;&gt; ROOT.xml

LABEL &quot;description&quot;=&quot;just for test&quot; &quot;version&quot;=&quot;1.0&quot;
ENV myName=&quot;Shengzhi Wang&quot; mySoft=&quot;Docker image build&quot;

CMD /usr/local/tomcat/bin/catalina.sh run
</code></pre><p>build_image_share里面有一个命名为show_books_base_on_angularJS_Underscore_master的war包,只有网页没有集成数据库。<br>然后在同目录下运行docker build -t showbooks .<br>生成镜像后运行docker run -d -p 8888:8080 showbooks<br>在本机访问localhost:8080查看结果</p>
<p>Dockerfile3              </p>
<pre><code>FROM tomcat:7.0.72-jre7
MAINTAINER WSZ

ADD build_image_share /build_image_share
RUN [&quot;chmod&quot;,&quot;+x&quot;, &quot;/build_image_share&quot;]

WORKDIR /usr/local/tomcat/webapps
RUN cp /build_image_share/shoppingweb.war shoppingweb.war

WORKDIR /usr/local/tomcat/conf
RUN sed -i~ &apos;/&lt;\/Host/i &lt;Context path=&quot;/&quot; docBase=&quot;shoppingweb.war&quot; debug=&quot;0&quot; privileged=&quot;true&quot; reloadable=&quot;true&quot;/&gt;&apos; server.xml

CMD /usr/local/tomcat/bin/catalina.sh run
</code></pre><h2 id="Dockerfile-优化方案"><a href="#Dockerfile-优化方案" class="headerlink" title="Dockerfile 优化方案"></a>Dockerfile 优化方案</h2><p>1.容器要尽可能短小精悍,在写Dockerfile之前确定容器要提供的服务,要可以快速的启动和停止,同时用最少的步骤来配置容器服务。<br>2.多使用.Dockerignore文件,当加载文件时过滤某些文件。<br>    当Docker加载文件时,如果发现目录存在.Dockerignore文件,那么此目录中符合.Dockerignore文件中定义规则的文件将会被过滤掉,不会被加载到缓存中。<br>    ./Dockerfile文件必须放到Dockerfile所在目录下面。./Dockerfile文件中的路径是以./Dockerfile所在目录为起点的。<br>3.不要安装非必需的软件包<br>4.一个容器尽量只运行一种服务<br>    为了达到容器可以快速部署的目的,应该尽量每个容器只对外提供一种服务。当容器需要其他服务时,通过link的方式从其他容器获取服务,而不是在当前容器再启动另外一种服务。<br>5.控制文件层数量<br>    文件层过多时,创建容器将会耗费更多的时间。<br>    可以将相似的命令放到同一个RUN指令中运行,以减少文件层数量。但是命令合并的太厉害,会影响到Dockerfile中RUN指令的可读性,导致Dockerfile的维护成本很高。<br>    要在文件层数量和可维护性之间找到平衡。<br>6.对命令中的参数进行排序</p>
<pre><code>RUN apt-get update &amp;&amp; apt-get install -y \
    bzr \
    cvs \
    git \
    subversion
</code></pre><p>对参数排序以后,可以避免下载重复的软件包,同时增添软件包时更为容易和控制,提高Dockerfile的可读性和可维护性。<br>默认规则,每行最后加空格和\<br>7.尽可能多使用缓存中的数据<br>    在Dockerfile执行过程中,Docker会讲某些命令的执行结果保存成临时镜像,保存在缓存中。在下次执行Dockerfile时,Docker会在执行每一条指令之前检测此条指令缓存值是否有效。只有当缓存没有或者缓存失效时,才会再次执行此条指令。<br>    若是不希望使用缓存中的结果,通过–no-cache=true来关闭此项功能。<br>    Docker加载完基础镜像之后,会对比由此基础镜像所派生出来的所有子镜像。对比规则就是看这些子镜像是否由Dockerfile后面的命令所创建的,如果后面的命令发生了变化,那么缓存自动失效。<br>    单纯的比较指令是否发生变化来判定缓存是否有效。ADD和COPY命令会检查其所涉及的文件是否发生了变更,标准是计算文件的校验和,而且只是校验镜像中的数据,不校验容器中的数据。<br>    一旦缓存的镜像失效,那么此缓存镜像以后的所有镜像都自动失效。</p>
<h2 id="某些命令"><a href="#某些命令" class="headerlink" title="某些命令"></a>某些命令</h2><p><strong>Delete all stopped containers</strong><br>docker rm $( docker ps -q -f status=exited)<br><strong>Delete all dangling (unused) images</strong><br>docker rmi $( docker images -q -f dangling=true)<br><strong>安装mysql server</strong><br>RUN apt-get update \<br>        &amp;&amp; apt-get install -y mysql-server<br><strong>mysql server启动</strong><br>docker run –name my-container-name -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql/mysql-server:tag<br><strong>重启mysql service</strong><br>service mysql restart<br>mysql -u root -p</p>
<p><strong>在容器外进入mysql</strong><br>docker exec -it mysql mysql -uroot -p<br><strong>加一个目录存数据</strong><br>docker run –name mysql2 -v /Users/szwang/DockerForMe/build_image/init_data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql/mysql-server</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>基于原先做的Shoppingweb项目,数据库是Mysql<br>修改root-context.xml相关的数据库的内容</p>
<pre><code>&lt;bean id=&quot;dataSource&quot;
            class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
            &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;
            &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://mysql:3306/shoppingdb?useUnicode=true&amp;amp;characterEncoding=UTF-8&quot; /&gt;
            &lt;property name=&quot;username&quot; value=&quot;shop&quot; /&gt;
            &lt;property name=&quot;password&quot; value=&quot;123456&quot; /&gt;
&lt;/bean&gt;
</code></pre><p>Dockerfile文件的内容如下:</p>
<pre><code>FROM tomcat:7.0.72-jre7
MAINTAINER WSZ

ADD build_image_share /build_image_share
RUN [&quot;chmod&quot;,&quot;+x&quot;, &quot;/build_image_share&quot;]

WORKDIR /usr/local/tomcat/webapps
RUN cp /build_image_share/shoppingweb.war shoppingweb.war

WORKDIR /usr/local/tomcat/conf
RUN sed -i~ &apos;/&lt;\/Host/i &lt;Context path=&quot;/&quot; docBase=&quot;shoppingweb.war&quot; debug=&quot;0&quot; privileged=&quot;true&quot; reloadable=&quot;true&quot;/&gt;&apos; server.xml

CMD /usr/local/tomcat/bin/catalina.sh run
</code></pre><p>template_envfile的内容如下:</p>
<pre><code>MYSQL_ROOT_PASSWORD=123456
MYSQL_ROOT_HOST=mysql
MYSQL_DATABASE=shoppingdb
MYSQL_USER=shop
MYSQL_PASSWORD=123456
</code></pre><p>在命令行里跑<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#下载mysql server</span></div><div class="line">docker pull mysql/mysql-server</div><div class="line"><span class="comment">#跑起一个数据库容器,root密码设置为123456,数据库的host设置为mysql,数据库名为shoppingdb,数据库用户名和密码为shop和123456</span></div><div class="line">docker run --name mysql2 --env-file ./template_envfile <span class="_">-d</span> mysql/mysql-server</div><div class="line"><span class="comment">#一样的效果</span></div><div class="line"><span class="comment">#docker run --name mysql -e MYSQL_ROOT_PASSWORD=123456 -e MYSQL_ROOT_HOST=mysql -e MYSQL_DATABASE=shoppingdb -e MYSQL_USER=shop -e MYSQL_PASSWORD=123456  -d mysql/mysql-server</span></div><div class="line"></div><div class="line"><span class="comment">#进入mysql容器,初始化数据库</span></div><div class="line">docker <span class="built_in">exec</span> -it mysql mysql -uroot -p</div><div class="line"><span class="comment">#如果Access denied失败,则运行docker exec -it mysql2 bash,在容器内运行mysql -u root -p</span></div><div class="line"><span class="comment">#运行sql文件</span></div><div class="line"></div><div class="line"><span class="comment">#启动运行应用的容器</span></div><div class="line">docker run --name shoppingwithlinkmysqlserver <span class="_">-d</span> -p 8080:8080 --env-file ./template_envfile --link mysql:mysql shoppingweb:2.0</div><div class="line"><span class="comment">#一样的效果</span></div><div class="line"><span class="comment">#docker run --name shoppingwithlinkmysqlserver -p 8080:8080 -d -e MYSQL_ROOT_PASSWORD=123456 -e MYSQL_ROOT_HOST=mysql -e MYSQL_DATABASE=shoppingdb -e MYSQL_USER=shop -e MYSQL_PASSWORD=123456 --link mysql:mysql shoppingweb:2.0</span></div></pre></td></tr></table></figure></p>
<p>参考书籍<br>《Docker 全攻略》张涛著   该本书有很长的篇幅介绍docker的命令<br><a href="https://docs.docker.com/" target="_blank" rel="external">《Docker 官方文档》</a><br><a href="https://hub.docker.com/r/mysql/mysql-server/" target="_blank" rel="external">mysql/mysql-server in Docker</a><br><a href="http://blog.awolski.com/using-docker-to-spin-up-databases-for-development/" target="_blank" rel="external">Using Docker to spin up databases for development</a><br><a href="http://txt.fliglio.com/2013/11/creating-a-mysql-docker-container/" target="_blank" rel="external">Creating a MySQL Docker Container</a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/11/28/Docker-learn3/" class="archive-article-date">
  	<time datetime="2016-11-28T06:30:41.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-11-28</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Docker/">Docker</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/technical/">technical</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-Docker-learn-first" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/17/Docker-learn-first/">Docker 学习笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Docker是什么"><a href="#Docker是什么" class="headerlink" title="Docker是什么"></a>Docker是什么</h2><p>Docker是一个开放源代码软件专案，让应用程序布署在软件容器下的工作可以自动化进行，借此在Linux操作系统上，提供一个额外的软件抽象层，以及操作系统层虚拟化的自动管理机制。<br>Docker目标是实现轻量级的操作系统虚拟化解决方案。减少软件开发周期中最繁琐、最耗时的环境准备环节。<br>Docker满足了免费的、轻量级、可移植、虚拟化、资源隔离、数据统一、语言无关、封装后的镜像可以随处部署和迁移这些要求。</p>
<h2 id="Docker优点"><a href="#Docker优点" class="headerlink" title="Docker优点"></a>Docker优点</h2><p>0）启动可以在秒级实现，比传统的虚拟机快很多<br>1）Docker的资源利用率比传统虚拟机要高，一台主机上可以同时运行数千个Docker容器<br>2）除了运行其中的应用，基本不消耗额外的系统资源，使得应用性能很高，同时系统开销小。<br>（传统的虚拟机方式运行10个不同的应用要10个虚拟机，Docker只要启动10个隔离的应用即可）<br>3）更快速的交付和部署，一次创建或配置可以在任意地方正常运行<br>4）更高效的虚拟化，Docker容器是内核级的虚拟化，可以实现更高的性能和效率<br>5）Docker支持跨节点部署，使得更轻松的迁移和扩展，Docker容器可以在任意的平台上运行，包括物理机、虚拟机、公有云、私有云、个人电脑、服务器等。兼容性高，用户可以把一个应用程序从一个平台直接迁移到另一个平台。“一次构建，自由分发。”<br>6）更简单的管理，小的修改代替大量的更新工作，所有的修改都以增量的方式被分发和更新，实现自动化并且高效的管理。<br>7）版本可控,组件可复用。镜像之间不是相互隔离的，镜像之间可以产生松耦合的关系。镜像是多层文件的联合体，这些文件层通过不同的组合可以产生不同的镜像，每一个镜像都有标签，标签代表了唯一的镜像，通过标签可以回溯加载特定的镜像。<br>8）共享镜像，Docker是开源的，构建的镜像可以上传到Docker Hub上<br>9）轻量，Docker是基于Linux内核进行的虚拟化操作，所有的容器共享内核资源的。</p>
<h2 id="Docker缺点"><a href="#Docker缺点" class="headerlink" title="Docker缺点"></a>Docker缺点</h2><p>1)宿主资源没有完成做到隔离<br>2)Golang语言尚未成熟<br>3)Docker虽已经开源,但在在未来可能收费</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/11/17/Docker-learn-first/" class="archive-article-date">
  	<time datetime="2016-11-17T08:09:07.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-11-17</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Docker/">Docker</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/technical/">technical</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-mxgraph" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/14/mxgraph/">mxgraph</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="mxgraph"><a href="#mxgraph" class="headerlink" title="mxgraph"></a>mxgraph</h2><p>mxGraph是一套用于图表图形的显示交互的开发工具库。支持的技术有：Java JavaScript PHP .NET。</p>
<p>Java版本用于创建高性能的桌面应用程序。<br>JavaScript版本的mxGraph是一个JS绘图组件,适用于需要在网页中设计/编辑Workflow/BPM流程图、图表、网络图和普通图形的Web应用程序,即主要用在所有的工作于网页浏览器本身的应用。</p>
<p>JavaScript版本主要技术优势:<br>    不需要第三方插件。<br>    涉及的技术是开放的。<br>    标准化的技术，应用程序可以轻松部署到最大数量的浏览器用户，而不需要在用户端的电脑进行额外的配置或安装。<br>JavaScript版本主要技术劣势：<br>    渲染速度。当用户屏幕上可见的单元数量攀升到数百时，在大多数浏览器上重绘减缓到超出可接受的水平。 在信息管理理论中，同时显示数百个单元通常是不正确的，因为用户无法一下子理解这么多的数据。有几种方法， 我们统称为复杂性管理机制，可以用来限制信息的数量，达到合理水平，从而保持可接受的重绘率。 复杂性管理在本用户手册后面的章节中有详细描述。</p>
<p>下载地址： <a href="http://www.jgraph.com/mxdownload.html" target="_blank" rel="external">http://www.jgraph.com/mxdownload.html</a><br>中文手册： <a href="http://www.mxgraph.cn/doc/mxgraph" target="_blank" rel="external">http://www.mxgraph.cn/doc/mxgraph</a> </p>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>在HTML页面加载mxGraph核心js文件即可使用mxGraph所有功能，几乎所有的js工具库都是这样使用的（JQuery ExtJs…）。 </p>
<p>下载mxGraph并解压<br><a href="https://github.com/jgraph/mxgraph/releases/tag/v3.6.0.0" target="_blank" rel="external">https://github.com/jgraph/mxgraph/releases/tag/v3.6.0.0</a></p>
<p>mxGraph/javascript/src 目录下包含了开发mxGraph项目所需要的所有东西,复制一份到项目中并指定正确的路径即可使用 </p>
<p>PS : 当显示的元素数量增多到上百个时， mxGraph的渲染速度会相当的缓慢。这将使用复杂性管理机制来解决。</p>
<h2 id="mxgraph的包"><a href="#mxgraph的包" class="headerlink" title="mxgraph的包"></a>mxgraph的包</h2><p>JavaScript的版本分成8个package。顶层是 mxClient 类。<br>editor package 提供实现图表编辑器所需的类在这个包中的主类是mxEditor。</p>
<p>view and model packages 实现图形组件, mxGraph. 它指的是一个 mxGraphModel包含 mxCells和 缓存 mxGraphView的cells状态.<br>handler, layout and shape packages 包含事件监听器、布局算法和形状, 事件监听器包括 mxRubberband for rubberband selection, mxTooltipHandler for tooltips and mxGraphHandler for basic cell modifications.  mxCompactTreeLayout implements a tree layout algorithm, and the shape package provides various shapes, which are subclasses of mxShape.<br>util package 提供了实用工具类包括mxclipboard复制粘贴, <mxdatatransfer>拖放, mxConstants 键和值的样式, mxEvent and mxUtils 跨浏览器的事件处理和通用函数,mxResources 国际化 and mxLog 控制台输出。<br>io package 实现将JavaScript对象到XML的通用 mxObjectCodec 。 主类是 mxCodec.  mxCodecRegistry 是全球注册自定义的编解码器。</mxdatatransfer></p>
<h2 id="hello-world简单例子"><a href="#hello-world简单例子" class="headerlink" title="hello,world简单例子"></a>hello,world简单例子</h2><p>显示hello和world两个格子相连。</p>
<p>1)新建一个helloWorld.html文件<br>2)放入一个container用于装载mxGraph<br>3)检测浏览器支持与否<br>4)画图</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></div><div class="line">        mxBasePath = 'src/';</div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"src/js/mxClient.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></div><div class="line">    function main(container) &#123;</div><div class="line">        // 检查浏览器支持</div><div class="line">        if (!mxClient.isBrowserSupported()) &#123;</div><div class="line">            mxUtils.error('Browser is not supported!', 200, false);</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            // 在指定容器中创建图形</div><div class="line">            var model = new mxGraphModel();</div><div class="line">            var graph = new mxGraph(container, model);</div><div class="line">            // 激活橡皮圈选择</div><div class="line">            new mxRubberband(graph);</div><div class="line">            // 拿到插入单元的默认父节点。</div><div class="line">            // 这通常是根节点的第一子节点（如0层）。</div><div class="line">            var parent = graph.getDefaultParent();</div><div class="line">            // 在一个步骤中，加入所有的单元到模型中</div><div class="line">            model.beginUpdate();</div><div class="line">            try &#123;</div><div class="line">                var v1 = graph.insertVertex(parent, null,</div><div class="line">                        'Hello', 20, 20, 80, 30);</div><div class="line">                var v2 = graph.insertVertex(parent, null,</div><div class="line">                        'World', 200, 150, 80, 30);</div><div class="line">                var e1 = graph.insertEdge(parent, null, '', v1, v2);</div><div class="line">            &#125;</div><div class="line">            finally &#123;</div><div class="line">                // 更新显示</div><div class="line">                model.endUpdate();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 页面传递图形的容器给程序 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">"main(document.getElementById('container'))"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>在script中的mxBasePath:<br>    一个JavaScript变量，用来定义CSS,图片,资源和js的使用的目录。是一段JavaScript代码,并需要被放置在脚本标记内。 它必须在加载mxClient.js之前,而且不应该斜线。</p>
<p>mxClient.js<br>    这是mxGraph库的路径。</p>
<p>onload=”main(document.getElementById(‘container’))”<br>    创建容器,onload加载网页时会被调用。它通过在传递即下定义的一个div 容器作为参数。<br>    mxGraph组件将被放置在这个div容器中。</p>
<p>mxClient.isBrowserSupported()<br>    任何mxGraph应用程序的第一行应该检查浏览器的支持，如果不支持应该适当退出。如果浏览器支持， mxGraph将在div容器内被创建，在开始/结束更新调用之间，三个单元被添加到图形中。</p>
<h2 id="部分方法"><a href="#部分方法" class="headerlink" title="部分方法"></a>部分方法</h2><p>// 无效<br>graph.setEnabled(false);</p>
<p>// 连接<br>graph.setConnectable(true);</p>
<p>// 提示信息<br>graph.setTooltips(true);</p>
<p>// 右键移动容器坐标轴<br>graph.setPanning(true);</p>
<p>// 容器大小自适应<br>graph.setResizeContainer(true);</p>
<p>// 使用浏览器默认的按键监听<br>new mxRubberband(graph);</p>
<p>// 动态改变样式<br>graph.getView().updateStyle = true;</p>
<p>// 重复连接<br>graph.setMultigraph(false);</p>
<p>// Label 将显示 Html 格式的 Value<br>graph.setHtmlLabels(true);</p>
<p>// 禁用浏览器默认的右键菜单栏<br>mxEvent.disableContextMenu(container);</p>
<p>// 允许移动 Vertex 的 Label<br>graph.setVertexLabelsMovable(true);</p>
<p>// 禁止改变元素大小<br>graph.setCellsResizable(false);</p>
<p>// 允许连线的目标和源是同一元素<br>graph.setAllowLoops(true);</p>
<p>//选中所有的线<br>raph.selectEdges();</p>
<p>//使线在所有元素的底下<br>graph.orderCells(true);</p>
<p>//取消选中的元素<br>graph.clearSelection();</p>
<p>——节点样式设置<br>1、如何设节点颜色？<br>通过属性fillColor（填充色）、gradientColor（渐变色），设为一样的颜色就是节点颜色了。<br>2、如何设置透明颜色？<br>在配置文件中none可设为默认颜色，transparent可设透明颜色<br>3、节点不可改变大小<br>0否，1是<br>4、节点与连线紧密连接，无空隙</p>
<p>5、节点颜色渐变方向？</p>
<p>6、如果不用配置文件？<br>你可以通过cell.setStyle(“XXXX”) 来实现样式的动态设置。<br>XXX形如：”样式属性=属性值;样式属性2=属性值2；”，可通过mxGraph官方doc搜索mxConstants来查找你需要的属性。<br>若设定选中节点的样式，还可通过graph.setCellStyles(mxConstants.属性,mxConstants.属性值);来设定该节点的样式。如：graph.setCellStyles(mxConstants.STYLE_GRADIENT_DIRECTION,mxConstants.DIRECTION_NORTH);<br>参考资料<br><a href="http://www.longboo.com/docs/mxGraph_jiaochen.htm" target="_blank" rel="external">mxGraph 教程1 - 开发入门指南</a><br><a href="http://www.mxgraph.cn/doc/mxgraph/" target="_blank" rel="external">mxGraph 用户手册 – JavaScript客户端</a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/11/14/mxgraph/" class="archive-article-date">
  	<time datetime="2016-11-14T02:17:26.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-11-14</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/technical/">technical</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-Docker-Learn" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/13/Docker-Learn/">Docker 学习笔记(一)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h1><p><a href="https://docs.docker.com/docker-for-mac/" target="_blank" rel="external">Mac 安装地址</a><br>关于在Ubuntu、CentOS和Debian系统安装Docker,<a href="https://www.gitbook.com/book/yeasy/docker_practice/details" target="_blank" rel="external">Docker —— 从入门到实践</a>书里有安装教程<br>其他系统安装Docker,参考<a href="https://docs.docker.com/engine/installation/" target="_blank" rel="external">官网</a></p>
<h2 id="Boot2Docker"><a href="#Boot2Docker" class="headerlink" title="Boot2Docker"></a>Boot2Docker</h2><p>Boot2Docker 是一个包含了 VirtualBox 虚拟软件、Docker 程序和Boot2Docker Management Tool的一个集合软件。Boot2Docker Management Tool是一个运行在Mac系统上的轻量级Linux虚拟机。<br>这个轻量级虚拟机完全运行在内存中,启动很快,体积很小。<br>通过Boot2Docker安装的Docker相当于运行在一个 VirtualBox 虚拟机中,而客户端运行在Mac OS 上。<br>(Mac直接安装Docker,不通过Boot2Docker安装感觉起来没什么区别啊?)</p>
<h1 id="Docker-三大组件"><a href="#Docker-三大组件" class="headerlink" title="Docker 三大组件"></a>Docker 三大组件</h1><p>仓库<br>镜像<br>容器</p>
<h1 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h1><p>Docker 官方维护了一个公共仓库<a href="https://hub.docker.com/" target="_blank" rel="external">Docker Hub</a></p>
<h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p>本地命令:docker login<br>会有提示输入用户名和密码,一次登录后,会记住登录信息。本地用户目录的 .dockercfg 中将保存用户的认证信息。</p>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p>命令为docker search 命令来查找官方仓库中的镜像，并利用docker pull 命令来将它下载到本地。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker search centos -s 3</div></pre></td></tr></table></figure></p>
<p>-s N(仅显示评价为 N 星以上的镜像)<br>下载命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker pull centos</div></pre></td></tr></table></figure></p>
<h2 id="私有仓库配置"><a href="#私有仓库配置" class="headerlink" title="私有仓库配置"></a>私有仓库配置</h2><p>参考书籍<a href="https://www.gitbook.com/book/yeasy/docker_practice/details" target="_blank" rel="external">Docker —— 从入门到实践</a></p>
<h1 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h1><h2 id="Docker-镜像分层"><a href="#Docker-镜像分层" class="headerlink" title="Docker 镜像分层"></a>Docker 镜像分层</h2><p>有3层,分别为:<br>  基础镜像<br>  中间件镜像<br>  应用镜像</p>
<h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker pull 镜像版本</div></pre></td></tr></table></figure>
<p>将从 Docker Hub 仓库下载一个符合要求的镜像<br>完整的命令为:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker pull registry.hub.docker.com/ubuntu:12.04</div></pre></td></tr></table></figure></p>
<p>即从注册服务器registry.hub.docker.com 中的 ubuntu 仓库来下载标记为 12.04 的镜像。</p>
<h2 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h2><p>下载镜像完成后，可以使用该镜像了，摘自书中的例子:创建一个容器，让其中运行 bash 应用。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker run -t -i ubuntu:12.04 /bin/bash</div></pre></td></tr></table></figure></p>
<h4 id="显示本地已有的镜像"><a href="#显示本地已有的镜像" class="headerlink" title="显示本地已有的镜像"></a>显示本地已有的镜像</h4><p>命令:docker images </p>
<h4 id="修改镜像"><a href="#修改镜像" class="headerlink" title="修改镜像:"></a>修改镜像:</h4><p><strong>1.docker commit 来扩展一个镜像</strong><br>镜像启动容器:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker run -t -i ubuntu:12.04 /bin/bash</div></pre></td></tr></table></figure></p>
<p> -t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， -i 则让容器的标准输入保持打开</p>
<p>在容器中添加json package:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">root@0b2616b0e5a8:/# gem install json</div></pre></td></tr></table></figure></p>
<p>退出: exit<br>提交更新后的副本:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo docker commit -m &quot;Added json gem&quot; -a &quot;Docker Newbee&quot; 0b2616b0e5a8 ouruser/sinatra:v2</div></pre></td></tr></table></figure></p>
<p>ouruser/sinatra:v2为目标镜像的仓库名和 tag 信息,如v2<br></p>
<p><strong>2.docker build 来创建一个新的镜像</strong><br>新建一个文件Dockerfile,里面的每一条指令都创建镜像的一层。<br></p>
<p>Dockerfile 基本的语法是:<br>    使用 # 来注释<br>    FROM 指令告诉 Docker 使用哪个镜像作为基础<br>    接着是维护者的信息<br>    RUN 开头的指令会在创建中运行，比如安装一个软件包，在这里使用 apt-get来安装了一些软件<br></p>
<p>编写完成 Dockerfile 后可以使用 docker build 来生成镜像。例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker build -t ouruser/sinatra:v2 .</div></pre></td></tr></table></figure></p>
<p>其中 -t 标记来添加 tag，指定新的镜像的用户信息。 “.” 是 Dockerfile 所在的路径（当前目录），也可以替换为一个具体的 Dockerfile 的路径。</p>
<h4 id="改变镜像标签内容"><a href="#改变镜像标签内容" class="headerlink" title="改变镜像标签内容"></a>改变镜像标签内容</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker tag 5db5f8471261 ouruser/sinatra:devel #5db...是镜像ID  后面的是修改后的标签</div></pre></td></tr></table></figure>
<h4 id="本地导入镜像"><a href="#本地导入镜像" class="headerlink" title="本地导入镜像:"></a>本地导入镜像:</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo cat ubuntu-14.04-x86_64-minimal.tar.gz |docker import - ubuntu:14.04</div></pre></td></tr></table></figure>
<h4 id="镜像上传到远程仓库"><a href="#镜像上传到远程仓库" class="headerlink" title="镜像上传到远程仓库:"></a>镜像上传到远程仓库:</h4><p>Docker Hub 上完成注册后，可以推送自己的镜像到仓库中<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker push ouruser/sinatra</div></pre></td></tr></table></figure></p>
<h4 id="保存镜像到本地文件"><a href="#保存镜像到本地文件" class="headerlink" title="保存镜像到本地文件:"></a>保存镜像到本地文件:</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker save -o ubuntu_14.04.tar ubuntu:14.04</div></pre></td></tr></table></figure>
<h4 id="从导出的本地文件中再加载到本地镜像库"><a href="#从导出的本地文件中再加载到本地镜像库" class="headerlink" title="从导出的本地文件中再加载到本地镜像库:"></a>从导出的本地文件中再加载到本地镜像库:</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ sudo docker load --input ubuntu_14.04.tar</div><div class="line">或</div><div class="line">$ sudo docker load &lt; ubuntu_14.04.tar</div></pre></td></tr></table></figure>
<h4 id="移除镜像"><a href="#移除镜像" class="headerlink" title="移除镜像"></a>移除镜像</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rmi training/sinatra</div></pre></td></tr></table></figure>
<p>在删除镜像之前要先用 docker rm 删掉依赖于这个镜像的所有容器。</p>
<p>清理所有未打过标签的本地镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo docker rmi $(docker images -q -f &quot;dangling=true&quot;)</div><div class="line">sudo docker rmi $(docker images --quiet --filter &quot;dangling=true&quot;)</div></pre></td></tr></table></figure></p>
<h1 id="Docker-容器"><a href="#Docker-容器" class="headerlink" title="Docker 容器"></a>Docker 容器</h1><p>容器是独立运行的一个或一组应用，以及它们的运行态环境。</p>
<h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><p>有两种方式:<br>1.基于镜像新建一个容器并启动<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker run -t -i ubuntu:12.04 /bin/bash</div></pre></td></tr></table></figure></p>
<p>使用docker run 来创建容器时，Docker 在后台运行的标准操作包括：</p>
<ul>
<li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li>
<li>利用镜像创建并启动一个容器</li>
<li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li>
<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>
<li>从地址池配置一个 ip 地址给容器</li>
<li>执行用户指定的应用程序</li>
<li>执行完毕后容器被终止</li>
</ul>
<p>2.将在终止状态（stopped）的容器重新启动<br>docker start命令，直接将一个已经终止的容器启动运行。可以利用 ps 或 top 来查看当前的进程信息。</p>
<h2 id="查看容器信息"><a href="#查看容器信息" class="headerlink" title="查看容器信息"></a>查看容器信息</h2><p>命令:docker ps<br>可以查看所有的容器及进程</p>
<h2 id="容器在后台运行"><a href="#容器在后台运行" class="headerlink" title="容器在后台运行"></a>容器在后台运行</h2><p>普通的docker run命令会在当前宿主机输出结果。<br>加上-d,此时容器会在后台运行并不会把输出的结果打印到宿主机上面,而是返回一个ID。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo docker run -d ubuntu:14.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</div></pre></td></tr></table></figure>
<p>查看输出结果可以用docker logs<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker logs [container ID or NAMES]</div></pre></td></tr></table></figure></p>
<p>里面可以是刚刚返回的ID也可以是NAME</p>
<h2 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h2><p>使用命令docker stop ID来终止</p>
<p>当Docker容器中指定的应用终结时，容器也自动终止。所以之前通过 exit 命令或 Ctrl+d 来退出终端时，所创建的容器立刻终止。<br>查看终止状态的容器可以用 docker ps -a命令。</p>
<h4 id="重启已经终止的容器"><a href="#重启已经终止的容器" class="headerlink" title="重启已经终止的容器"></a>重启已经终止的容器</h4><p>处于终止状态的容器，可以通过 docker start 命令来重新启动。<br>docker restart 命令会将一个运行态的容器终止，然后再重新启动它。</p>
<h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><p>当容器进入后台时,需要进入容器的操作<br>使用Attach命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker run -idt ubuntu <span class="comment">#后台运行</span></div><div class="line">docker ps <span class="comment">#查看进程</span></div><div class="line">docker attach 容器名或者ID</div></pre></td></tr></table></figure></p>
<p>使用nsenter 命令<br>nsenter工具在 util-linux 包2.23版本后包含,设备上没有的,需要手动安装。<br>详细步骤参考书籍<a href="https://www.gitbook.com/book/yeasy/docker_practice/details" target="_blank" rel="external">Docker —— 从入门到实践</a></p>
<h2 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h2><p>导出本地某个容器，使用 docker export 命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker export 容器ID &gt; ubuntu.tar(文件名)</div></pre></td></tr></table></figure></p>
<h2 id="导入容器"><a href="#导入容器" class="headerlink" title="导入容器"></a>导入容器</h2><p>使用docker import从容器快照文件中再导入为镜像:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ cat ubuntu.tar | docker import - <span class="built_in">test</span>/ubuntu:v1.0(镜像名和标签)</div><div class="line">$ docker images <span class="comment">#查看结果</span></div></pre></td></tr></table></figure></p>
<p>或者通过指定 URL 或者某个目录来导入，例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$sudo docker import http://example.com/exampleimage.tgz example/imagerepo</div></pre></td></tr></table></figure></p>
<p><strong>用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，<br>也可以使用 docker import 来导入一个容器快照到本地镜像库。<br>这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。<br>此外，从容器快照文件导入时可以重新指定标签等元数据信息。</strong></p>
<h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><p>使用 docker rm 来删除一个处于终止状态的容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$sudo docker rm trusting_newton</div></pre></td></tr></table></figure></p>
<p>如果要删除一个运行中的容器，可以添加 -f 参数。<br>清理所有处于终止状态的容器,使用以下命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rm $(docker ps -a -q)</div></pre></td></tr></table></figure></p>
<p>书籍:<br><a href="https://www.gitbook.com/book/yeasy/docker_practice/details" target="_blank" rel="external">Docker —— 从入门到实践</a>此处有电子书的下载途径</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/11/13/Docker-Learn/" class="archive-article-date">
  	<time datetime="2016-11-13T12:14:25.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-11-13</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Docker/">Docker</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/technical/">technical</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-Docker-Learn2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/13/Docker-Learn2/">Docker 学习笔记(二)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Docker中的某些命令详解"><a href="#Docker中的某些命令详解" class="headerlink" title="Docker中的某些命令详解"></a>Docker中的某些命令详解</h2><h4 id="logs-获取容器内部应用输出的日志-只能获取到重定向到STDOUT和STDERR的日志"><a href="#logs-获取容器内部应用输出的日志-只能获取到重定向到STDOUT和STDERR的日志" class="headerlink" title="logs 获取容器内部应用输出的日志,只能获取到重定向到STDOUT和STDERR的日志"></a>logs 获取容器内部应用输出的日志,只能获取到重定向到STDOUT和STDERR的日志</h4><h4 id="attach-挂载到正在运行的容器中-并且可以在容器中执行任何命令"><a href="#attach-挂载到正在运行的容器中-并且可以在容器中执行任何命令" class="headerlink" title="attach 挂载到正在运行的容器中,并且可以在容器中执行任何命令"></a>attach 挂载到正在运行的容器中,并且可以在容器中执行任何命令</h4><p>可以通过ID和name挂载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">➜  ~ docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</div><div class="line">6caf2b2b8d00        b1873e247b48        &quot;/bin/bash&quot;         32 minutes ago      Up 32 minutes                           reverent_thompson</div><div class="line">➜  ~ docker attach 6caf2b2b8d00</div><div class="line">root@6caf2b2b8d00:/#</div></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜  ~ docker attach reverent_thompson</div><div class="line">root@6caf2b2b8d00:/#</div></pre></td></tr></table></figure></p>
<p>通过Ctrl+P+Q来退出容器,容器还在运行中。<br>使用exit退出容器,容器同步被关闭。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">root@6caf2b2b8d00:/# exit 10</div><div class="line">➜  ~ docker ps -a |grep reverent_thompson</div><div class="line">6caf2b2b8d00        b1873e247b48         &quot;/bin/bash&quot;              52 minutes ago      Exited (10) 45 seconds ago                       reverent_thompson</div></pre></td></tr></table></figure></p>
<p>Exited (10) 容器的退出响应码变成了10,即可以通过exit命令来指定容器退出码。</p>
<h4 id="commit-以某个容器为基础保存成一个新的image"><a href="#commit-以某个容器为基础保存成一个新的image" class="headerlink" title="commit 以某个容器为基础保存成一个新的image"></a>commit 以某个容器为基础保存成一个新的image</h4><p>-a, –author=””这个参数的目标是保存新的作者。<br>-c, –change=[]这个参数保存的是修改image里面的配置参数。<br>目前支持的可以修改的配置参数有CMD|ENTRYPOINT|ENV|EXPOSE|LABEL|ONBUILD|USER|VOLUME|WORKDIR。其余的参数继承于上一个image<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜  ~ docker commit --change &quot;ENV DEBUG true&quot; 3af7938d2d31 svendowideit/testimage:version1</div><div class="line">sha256:c24a8c4cf76d9485e69fa4d975a6b8ccc3070dbf368a118672ab6a76a4249605</div></pre></td></tr></table></figure></p>
<p>3af7938d2d31是一个正在运行的容器,svendowideit/testimage是repository的名字,version1是tag的内容<br>查看结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜  ~ Docker inspect -f &quot;&#123;&#123; .Config.Env&#125;&#125;&quot; c24a8c4cf76d</div><div class="line">[DEBUG=true no_proxy=local PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin]</div></pre></td></tr></table></figure></p>
<p>-m, –message=””这个参数是提交一个comment备注信息,说明image的用途,修改的内容等信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">➜  ~  docker commit -m &quot;test message&quot; 3af7938d2d31 svendowideit/testimage:version2</div><div class="line">sha256:0d4f24b6a8d7d7239b9cfa163845c09866f30de9cc7ac23d48510e3ac095f6a4</div><div class="line">➜  ~ Docker inspect 0d4f24b6a8d7</div><div class="line">[</div><div class="line">    &#123;</div><div class="line">        &quot;Id&quot;: &quot;sha256:0d4f24b6a8d7d7239b9cfa163845c09866f30de9cc7ac23d48510e3ac095f6a4&quot;,</div><div class="line">        &quot;RepoTags&quot;: [</div><div class="line">            &quot;svendowideit/testimage:version2&quot;</div><div class="line">        ],</div><div class="line">        &quot;RepoDigests&quot;: [],</div><div class="line">        &quot;Parent&quot;: &quot;sha256:78a0e8d9b39cdcbb93d433ec5de61ba6c6d10369eccdf45b7e60318b47356d9a&quot;,</div><div class="line">        &quot;Comment&quot;: &quot;test message&quot;,</div><div class="line">        .........</div><div class="line">     &#125;</div><div class="line">]</div></pre></td></tr></table></figure></p>
<p>-p, –pause=true 默认情况下执行commit时,容器中所有进程处于暂停状态,如果此时容器对外提供服务,那其他容器会受到影响。<br>-pause=false使用这个参数使得在执行commit时保持容器内进程继续工作。但是commit效率会下降。</p>
<h4 id="create-创建容器"><a href="#create-创建容器" class="headerlink" title="create 创建容器"></a>create 创建容器</h4><p>create命令是以image为模板创建的一个容器,并且在容器文件的最上面一层添加一个读写层,容器里面的数据变化会被保存在读写层。<br>create成功后需要通过start来启动容器。<br>参数:<br>-i 将Host的Stdin和容器的Stdin相连接<br>-t 创建一个pty终端<br>(-it 前两者结合使用相当于在host环境中启动一个链接容器的pty伪终端,在host的pty中输入的数据就会传到容器之中。)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">➜  ~ docker create -it addwszfile bash</div><div class="line">7019c6b575fe673954f2019a99fb6679b7a2f4a604d324290ff5111c42feae2b</div><div class="line">➜  ~ docker create -it -v /dockerforme/sinatra/share_folder/:/tmp --name data1 addwszfile</div><div class="line">7cfc3205a8df843d1b7219a31f51976b5df638cb20a03c57134ec690da990875</div><div class="line">➜  ~ docker create -P --name data2 addwszfile</div></pre></td></tr></table></figure></p>
<p>addwszfile是image名称。</p>
<p>-p 映射网络端口,当应用需要访问其他应用或被访问,需要开放一个端口<br>-P 容器中所有需要暴露的端口都会映射到主机随机的一个端口(端口范围49153~65535)<br>-v 挂载参数,把主机的一个文件或者一个目录挂载到容器中</p>
<h4 id="diff-比较容器文件文件层数据差异的命令"><a href="#diff-比较容器文件文件层数据差异的命令" class="headerlink" title="diff 比较容器文件文件层数据差异的命令"></a>diff 比较容器文件文件层数据差异的命令</h4><p>首先启动一个容器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker run -t -i ubuntu:12.04 /bin/bash</div></pre></td></tr></table></figure></p>
<p>在容器中做某些操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">root@543f21cb4a4e:/# touch /tmp/wsz.txt</div><div class="line">root@543f21cb4a4e:/# echo &quot;This is wsz add test&quot; &gt; /tmp/wsz.txt</div><div class="line">root@543f21cb4a4e:/# touch /tmp/wsz2.txt</div><div class="line">root@543f21cb4a4e:/# rm /tmp/wsz2.txt</div><div class="line">root@543f21cb4a4e:/# touch /tmp/wsz3.txt</div><div class="line">root@543f21cb4a4e:/# echo &quot;This is a change test&quot; &gt; /tmp/wsz3.txt</div><div class="line">root@543f21cb4a4e:/# echo &quot;I add a new line&quot; &gt;&gt; /tmp/wsz3.txt</div></pre></td></tr></table></figure></p>
<p>新开一个命令行窗口,查看diff<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">➜  ~ docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</div><div class="line">543f21cb4a4e        ubuntu:12.04        &quot;/bin/bash&quot;         4 minutes ago       Up 4 minutes                            trusting_bell</div><div class="line">➜  ~ docker diff 543f21cb4a4e</div><div class="line">C /tmp</div><div class="line">A /tmp/wsz.txt</div><div class="line">A /tmp/wsz3.txt</div></pre></td></tr></table></figure></p>
<p>结果中的A表示add;C表示Change;D表示Delete<br>可以看见之中我们是创建一个wsz2.txt的文件然后又删除了,但是在diff中并没有反应出来,这是因为我们操作产生的数据保存在最上面的读写层里,diff比较的是最上层和其他层的差异,其中wsz2的文件不存在于其他层所以不显示。<br>若想时时刻刻保存状态,可以save读写层,再进行删除。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">➜  ~ docker commit 543f21cb4a4e addwszfile</div><div class="line">sha256:b1873e247b48d2ffb12725552691db3c8a2d1f097efdfbb04aeddb9cf13d8c9c</div><div class="line">➜  ~ docker run -it b1873e247b48d2ffb12725552691db3c8a2d1f097efdfbb04aeddb9cf13d8c9c</div><div class="line">root@6caf2b2b8d00:/# rm /tmp/wsz.txt</div></pre></td></tr></table></figure></p>
<p>新开一个命令行窗口可以看到删除的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">➜  ~ docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</div><div class="line">6caf2b2b8d00        b1873e247b48        &quot;/bin/bash&quot;         40 seconds ago      Up 39 seconds                           reverent_thompson</div><div class="line">➜  ~ docker diff 6caf2b2b8d00</div><div class="line">C /tmp</div><div class="line">D /tmp/wsz.txt</div></pre></td></tr></table></figure></p>
<h4 id="events-获取容器所报告的事件"><a href="#events-获取容器所报告的事件" class="headerlink" title="events 获取容器所报告的事件"></a>events 获取容器所报告的事件</h4><p>Docker容器再运行过程中会向Docker Daemon报告如下事件:<br>create、destroy、die、export、kill、oom、pause、start、stop、unpause<br>Image镜像会向Docker Daemon报告untag、delete事件<br>筛选的几种方式:<br>–since 指从某一个时间点开始Docker Daemon接收的所有事件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜  ~ docker events --since &apos;2016-09-01&apos;</div></pre></td></tr></table></figure></p>
<p>–until 需要和 –since结合使用,指的是从某一个时间点开始到某一个时间点结束。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜  ~ docker events --since &apos;2016-09-01&apos; --until &apos;2016-11-08T15:00:00&apos;</div></pre></td></tr></table></figure></p>
<p>–filter 接收的是key=value的键值对。目前有效的key是container、event、image。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">➜  ~ docker events --filter &apos;event=stop&apos;</div><div class="line">➜  ~ docker events --filter &apos;image=ubuntu:14.04&apos;</div><div class="line">➜  ~ docker events --filter &apos;container=543f21cb4a4e&apos;</div></pre></td></tr></table></figure></p>
<h4 id="exec-在容器中运行其他命令"><a href="#exec-在容器中运行其他命令" class="headerlink" title="exec 在容器中运行其他命令"></a>exec 在容器中运行其他命令</h4><p>执行ps删选进程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜  ~ docker exec 6caf2b2b8d00 ps -s|grep bash</div></pre></td></tr></table></figure></p>
<p>创建一个新文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜  ~ docker exec 6caf2b2b8d00 touch /tmp/1.txt</div></pre></td></tr></table></figure></p>
<p>修改文件,前提需要申请一个pty和绑定一个stdin用来保存编辑的文件,因为没有pty容器无法收到控制字符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜  ~ docker exec -it 6caf2b2b8d00 vi /tmp/1.txt</div></pre></td></tr></table></figure></p>
<h4 id="history-追踪image的历史记录"><a href="#history-追踪image的历史记录" class="headerlink" title="history 追踪image的历史记录"></a>history 追踪image的历史记录</h4><p>diff 查看的是容器中文件系统的变更历史。History查看的是image的变更历史。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜  ~ docker history ouruser/sinatra:v3</div></pre></td></tr></table></figure></p>
<p>-H,–human 表示是否输出方便用户识别的格式。<br>–no-trunc=false 默认false,表示将输出按照一定的格式进行截断。<br>–quiet 若是设置为true,只返回image构建过程中所有的临时文件层的image ID,为false时返回所有信息。</p>
<h4 id="info-显示Docker摘要信息"><a href="#info-显示Docker摘要信息" class="headerlink" title="info 显示Docker摘要信息"></a>info 显示Docker摘要信息</h4><p>info 指令显示Docker摘要信息,用来确认Docker信息。包含Docker内核版本号、Docker所设定的CPU、内存参数等环境底层信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜  ~ docker info</div></pre></td></tr></table></figure></p>
<h4 id="inspect-返回指定目标的底层信息"><a href="#inspect-返回指定目标的底层信息" class="headerlink" title="inspect 返回指定目标的底层信息"></a>inspect 返回指定目标的底层信息</h4><p>inspect可以返回image和container的底层信息。包括某个容器的IP地址,MAC地址,端口信息等等。<br>返回的几类信息:<br>1.基本信息类:名称,创建时间,当前状态(运行、停止、暂停)等<br>2.运行参数类:网络信息、环境变量、主机名称等<br>3.底层数据类:CPU设置、内存设置、虚拟化设置等<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker inspect -f &#123;&#123;要查看的参数名&#125;&#125; ID号</div><div class="line">docker inspect -f &apos;&#123;&#123;json .Config&#125;&#125;&apos; ID号</div><div class="line">docker inspect -f &apos;&#123;&#123;(index (index .Config &quot;Env&quot;) 0)&#125;&#125;&apos; ID号              取出Config中Env第一个元素命令</div></pre></td></tr></table></figure></p>
<p>json是指把数据格式化成json字符串<br>index取第几个</p>
<h4 id="kill-强制停止容器"><a href="#kill-强制停止容器" class="headerlink" title="kill 强制停止容器"></a>kill 强制停止容器</h4><p>一般使用stop关掉容器。出现异常使用kill<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker kill 容器名</div></pre></td></tr></table></figure></p>
<h4 id="ps-查看当前容器的运行状态"><a href="#ps-查看当前容器的运行状态" class="headerlink" title="ps 查看当前容器的运行状态"></a>ps 查看当前容器的运行状态</h4><h4 id="rename-对容器重命名"><a href="#rename-对容器重命名" class="headerlink" title="rename 对容器重命名"></a>rename 对容器重命名</h4><p>docker rename 旧名字 新名字</p>
<h4 id="tag-对镜像重命名"><a href="#tag-对镜像重命名" class="headerlink" title="tag 对镜像重命名"></a>tag 对镜像重命名</h4><p>……还有很多命令看文档</p>
<p>参考书籍<br>《Docker 全攻略》张涛著<br><a href="https://docs.docker.com/" target="_blank" rel="external">《Docker 官方文档》</a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/11/13/Docker-Learn2/" class="archive-article-date">
  	<time datetime="2016-11-13T12:14:25.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-11-13</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Docker/">Docker</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/technical/">technical</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  


      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 Shengzhi Wang
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
  本站总访问量 <span id="busuanzi_value_site_pv"></span> 次, 访客数 <span id="busuanzi_value_site_uv"></span> 人次, 本文总阅读量 <span id="busuanzi_value_page_pv"></span> 次

  <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

</footer>

    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/"
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
      <li data-hook="tools-section-friends"><span class="text">友链</span><i class="icon-link"></i></li>
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<a href="/tags/Angular/" style="font-size: 16.67px;">Angular</a> <a href="/tags/CI/" style="font-size: 10px;">CI</a> <a href="/tags/Docker/" style="font-size: 16.67px;">Docker</a> <a href="/tags/Github/" style="font-size: 10px;">Github</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/ansible/" style="font-size: 10px;">ansible</a> <a href="/tags/essays/" style="font-size: 13.33px;">essays</a> <a href="/tags/html5/" style="font-size: 13.33px;">html5</a> <a href="/tags/pipeline/" style="font-size: 10px;">pipeline</a> <a href="/tags/technical/" style="font-size: 20px;">technical</a>
    			</div>
    	</section>
    

    
    	<section class="tools-section tools-section-friends">
  		
  			<div class="friends-wrap" id="js-friends">
  			
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/wszhi">我的Github</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://blog.csdn.net/u012138931">我的CSDN</a>
  	        
  	        </div>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">靡不有初，&lt;br&gt;&lt;br&gt;鲜克有终。&lt;br&gt;&lt;br&gt;不断努力,一步一步往前走,做最好的自己</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>
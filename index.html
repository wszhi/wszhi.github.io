<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Shengzhi Wang</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="靡不有初,鲜克有终">
<meta property="og:type" content="website">
<meta property="og:title" content="Shengzhi Wang">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Shengzhi Wang">
<meta property="og:description" content="靡不有初,鲜克有终">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Shengzhi Wang">
<meta name="twitter:description" content="靡不有初,鲜克有终">
  
    <link rel="alternative" href="/atom.xml" title="Shengzhi Wang" type="application/atom+xml">
  
  
    <link rel="icon" href="//favicon.png">
  
  <script src="/style.js"></script>
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="http://store.aimon.cn/Product/photo/348/2012101905747.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Shengzhi Wang</a></h1>
		</hgroup>

		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/tags/technical/">技术</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">友链</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="3" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/wszhi" title="github">github</a>
		        
					<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
		        
					<a class="rss" target="_blank" href="#" title="rss">rss</a>
		        
					<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">Shengzhi Wang</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="http://store.aimon.cn/Product/photo/348/2012101905747.jpg" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">Shengzhi Wang</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/tags/technical/">技术</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/wszhi" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        
  
    <article id="post-Docker-learn3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/28/Docker-learn3/">Docker 学习笔记(三)--创建image</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="build-构建一个镜像"><a href="#build-构建一个镜像" class="headerlink" title="build 构建一个镜像"></a>build 构建一个镜像</h2><p>读取配置文件构建image(文件名默认Dockerfile,也可以自定义):<br>1)”-“表示将从STDIN读入数据,即将Dockerfile中的数据通过STDIN传入build中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Docker build - &lt; Dockerfile</div></pre></td></tr></table></figure></p>
<p>2)PATH参数表示Dockerfile全路径,即将Dockerfile放置到$(HOME)/Users目录下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Docker build $(HOME)/Users/Dockerfile</div><div class="line">Docker build $(HOME)/Users/otherfile    名字可变</div></pre></td></tr></table></figure></p>
<p>3)使用URL参数,URL必须指向一个git地址。Docker会把指定的git仓库克隆到本地,然后把仓库中的Dockerfile内容传给Docker Daemon。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Docker build https://github.com/wszhi/Docker-image.git#container:Docker</div></pre></td></tr></table></figure></p>
<p>以上命令通知Docker Daemon加载<a href="https://github.com/wszhi/Docker-image.git" target="_blank" rel="external">https://github.com/wszhi/Docker-image.git</a> 仓库,切换到container分支,在Docker目录下的Dockerfile文件来构建image。<br>注意: “:”后面的是Dockerfile文件的路径,此方式不支持自定义命名。若为master分支#后为空<br>若当前目录有Dockerfile文件可以省略路径使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Docker build --rm=false .</div></pre></td></tr></table></figure></p>
<p>–rm=false表示不删除临时镜像,当经常构建且变化不大的时候建议使用。</p>
<h4 id="build-构建镜像三要素"><a href="#build-构建镜像三要素" class="headerlink" title="build 构建镜像三要素"></a>build 构建镜像三要素</h4><p>build命令构建镜像是用Dockerfile文件中的指令来构建的,三个要素为:Dockerfile文件、所涉及文件和镜像参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Docker build -t image_name .</div></pre></td></tr></table></figure></p>
<p>默认执行Dockerfile文件。</p>
<h4 id="build命令执行的主要逻辑"><a href="#build命令执行的主要逻辑" class="headerlink" title="build命令执行的主要逻辑"></a>build命令执行的主要逻辑</h4><p>1)获取Dockerfile文件——客户端<br>2)加载Dockerfile文件所在目录下的所有文件——-客户端<br>3)解析Dockerfile文件指令<br>4)执行文件内指令,判断是否存在有效缓存镜像<br>5)执行指令</p>
<p>其中获取Dockerfile文件的方式有三种:<br>1.通过标准输入传入,参数”-“;<br>2.通过远程方式获取,git;<br>3.通过指定路径方式获取。</p>
<h4 id="build命令构建镜像原理"><a href="#build命令构建镜像原理" class="headerlink" title="build命令构建镜像原理"></a>build命令构建镜像原理</h4><p>客户端将Dockerfile所需要的文件和镜像参数传递给Daemon。<br>然后Daemon处理客户端传来的各项参数(为后续的解压操作和文件I/O操作做准备)。<br>当参数处理完成之后,Daemon开始解压文件,抽取文件。<br>最后Daemon解析Dockerfile,生成指令语法树。<br>之后Daemon使用解析后的指令从已经初始化的指令——函数对应表中找到对应的处理函数,最后执行函数。</p>
<p>流程:<br>(客户端)<br>加载Dockerfile—&gt;压缩构建目录—&gt;添加镜像参数——发送构建请求—-&gt;<br>(服务端)<br>—-&gt;生成构建参数—&gt;获取压缩包—&gt;解压文件—&gt;解析Dockerfile生成语法树—&gt;初始化指令处理对照表—&gt;循环执行指令—&gt;删除解压文件—&gt;构建完成</p>
<h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>Dockerfile 文件记录着用户”创建”镜像过程中需要执行的所有命令,Docker可以读懂的脚本文件。<br>镜像指的是一组特定的文件层,镜像的构建过程就是Docker执行Dockerfile所定义命令而形成这组文件层的过程。</p>
<h4 id="Dockerfile-内置命令"><a href="#Dockerfile-内置命令" class="headerlink" title="Dockerfile 内置命令"></a>Dockerfile 内置命令</h4><p><strong>FROM 指明基础镜像名称,必填</strong></p>
<pre><code>FROM &lt;image&gt;
FROM &lt;image&gt;:&lt;tag&gt;
FROM &lt;iamge&gt;@&lt;digest&gt;
</code></pre><p>当同时构建多个image时,可以出现多次FROM,但是只会返回最后一个镜像的ID,前几个会被标记为<none>:<none></none></none></p>
<p><strong>MAINTAINER 备注信息,包括作者、版本等,可选填</strong></p>
<pre><code>MAINTAINER 作者
</code></pre><p><strong>RUN 用于执行后面的命令,当RUN执行完毕后,将产生一个新的文件层,可选填</strong></p>
<pre><code># 当镜像中有/bin/sh
RUN &lt;command&gt;
# 当镜像中没有/bin/sh,使用以下方案,可以执行基础镜像中任意一个二进制程序,注意只能用双引号
RUN [&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;echo hello&quot;]
</code></pre><p>镜像最多只能保存126个文件层,包括基础镜像的文件层;执行一次RUN就会产生一个文件层。</p>
<p><strong>CMD 指定此镜像启动时默认执行命令,可选填</strong></p>
<pre><code>#推荐用法,其设定的命令将作为容器启动时的默认执行命令
CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]
#param 将作为ENTERPOINT的默认参数使用
CMD [&quot;param1&quot;,&quot;param2&quot;]
#将后面的命令作为shell命令,依靠/bin/sh -C 来执行
CMD command param1 param2
example: CMD echo &quot;This is a test&quot; | wc -
</code></pre><p>一个Dockerfile可以有多个CMD命令,可是只有最后一个CMD命令生效,CMD中也只能出现双引号,如果使用环境变量使用sh -C。</p>
<p><strong>LABEL 在镜像中添加元数据。例如版本号、构建日期等,可选填</strong></p>
<pre><code>LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...
</code></pre><p>使用键值对的形式来向镜像文件中添加元数据的命令<br>如果键值对中存在空格,则需要使用双引号来回避错误<br>一个LABEL命令也会产生新的文件层</p>
<pre><code>LABEL &quot;description&quot;=&quot;just for test&quot; &quot;version&quot;=&quot;1.0&quot;
</code></pre><p><strong>EXPOSE 指定需要暴露的网络端口号,可选填</strong></p>
<pre><code>EXPOSE 8080
CMD [&quot;catalina.sh&quot;,&quot;run&quot;]
</code></pre><p>当容器运行时,来通知Docker这个容器中哪些端口是应用程序用来监听的,这些端口不会被外部网络访问到,只能被主机的其他容器访问。</p>
<p><strong>ENV 在镜像中添加环境变量,可选填</strong></p>
<pre><code># 第一个字符为key,后面所有字符为value
ENV &lt;key&gt; &lt;value&gt;
左边为key,右边为value,value有空格时,需要&quot;\&quot;转义或者使用双引号
ENV &lt;key&gt;=&lt;value&gt; ....
</code></pre><p><strong>ADD 向镜像添加新文件或者新目录,可选填</strong><br>将src标记的文件,添加到容器中的dest所标记的路径中去。src标记的文件可以是本地文件,可以是本地目录,甚至可以是URL链接。<br>src标记的是本地文件或者目录时,其相对路径应该是相对于Dockerfile所在目录的路径,而dest则应该指向容器中的目录。如果这个目录不存在,当ADD命令执行时,将会在容器中自动创建此目录。<br>在src标记的路径中,允许使用通配符。而dest路径不能使用通配符,必须是绝对路径,或者相对于WORKDIR的相对路径。</p>
<pre><code>#添加所有以hom开头的文件
ADD hom* /mydir/
# ? 号可以被任意单个字符所代替
ADD hom?.txt /mydir/
</code></pre><p>规则:<br> 1.src指定路径必须存在于Dockerfile所在目录。因为在Dockerfile执行时,Docker daemon会读取Dockerfile所在目录的所有数据。如果ADD命令使用的文件在此目录中不存在,那么daemon将找不到指定文件。<br> 2.如果src指定的是URL,并且dest所指定的路径没有以”/“结尾,那么URL下载的数据将直接覆盖dest所给定的文件。<br> 3.如果src指定的是URL,并且dest所指定的路径以”/“结尾,那么URL下载后的数据将直接写入dest所指定的目录中。<br> 4.如果src指向一个目录,那么ADD指令将包括元数据在内的所有数据复制到容器中dest指定的文件中,但src所指定的目录本身不会被复制进去,只会复制此目录下的文件。<br> 5.如果src指向的是一个已知格式的压缩文件。当添加到容器之后会自动执行解压缩动作。从而从URL中下载的压缩文件则不会执行解压缩。<br> 6.如果src使用通配符指定了多个文件,那么此时dest必须是一个以”/“结尾的目录。<br> 7.如果dest指向的路径没有以”/“结尾,那么这个路径指向的文件将会被src指定的文件覆盖。<br> 8.如果dest指向的路径不存在,那么此路径中所涉及的父级目录都将会被创建。<br> 9.当src指向的URL没有下载权限时,首先需要使用RUN wget或者RUN curl获取文件。<br> 10.当ADD命令所标记的文件发生变化时,从变化的那个ADD命令开始,保存在缓存中的镜像将会实效,同时RUN命令产生的镜像也会失效。<br><strong>COPY 从主句镜像复制文件,可选填</strong><br>向容器中指定的路径下添加文件。</p>
<pre><code>#添加所有以hom开头的文件
COPY hom* /mydir/
# ? 号可以被任意单个字符所代替
COPY hom?.txt /mydir/    
</code></pre><p>1-1<br>2-4<br>3-6<br>4-7<br>5-8<br>6如果使用STDIN输入Dockerfile内容,那么Docker命令将会失效。</p>
<p><strong>ENTRYPOINT 在镜像中设定默认执行的二进制程序,可选填</strong><br>ENTRYPOINT用来设定容器运行时默认执行程序的命令。</p>
<pre><code>#第一种,推荐使用,可以自行设定需要执行的二进制程序和参数。
ENTRYPOINT [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] 
#第二种,将所设定的二进制程序限制在/bin/sh -C 下执行。
ENTRYPOINT command param1 param2
</code></pre><p>ENTRYPOINT可以出现多次,只有最后一次起作用。<br>CMD指定的值将作为参数附加到ENTRYPOINT里的命令之后。如果run命令后面添加了其他参数,此时的CMD指定的参数将会失效。<br>第二种用法,ENTRYPOINT 命令设定的二进制程序将会忽略所有来自于CMD和RUN命令后面所添加的所有参数,只会运行ENTRYPOINT命令所设定的二进制程序。<br>为了确保容器可以正确处理stop命令发来的SIG信号,Docker建议使用exec来启动二进制程序。</p>
<p><strong>VOLUME 向镜像挂载一个卷组,可选填</strong></p>
<pre><code>VOLUME [&quot;/data&quot;]
</code></pre><p>VOLUME可以在容器内部创建一个指定名称的挂载点。<br>如果以及在Dockerfile里声明了某个挂载点,那么以后对此挂载点种文件的操作将不会生效。一般在Dockerfile结尾处声明挂载点。</p>
<pre><code>FROM nginx
COPY content /usr/share/nginx/html
COPY conf /etc/nginx
VOLUME /usr/share/nginx/html
VOLUME /etc/nginx
</code></pre><p>构建镜像</p>
<pre><code>Docker build -t mynginximage .
</code></pre><p>创建容器</p>
<pre><code>Docker run --name mynginx -P -d mynginximage
Docker run -it --volumes-from mynginx --name mynginxfiles debian /bin/bash
</code></pre><p>–volumes-from,从mynginx继承了配置文件信息,此时在mynginxfiles当中只能看到继承文件的信息而无法看到其他文件。在这个容器中可以任意编写配置文件而不会影响其他文件和容器。<br><strong>USER 在镜像构建过程中,生成或者切换到另外一个用户,可选填</strong></p>
<pre><code>USER daemon
</code></pre><p>切换用户身份,当执行完USER命令后,其后面所有的命令都将以新用户的身份来执行。</p>
<p><strong>WORKDITR 设定此镜像后续操作的默认工作目录,可选填</strong></p>
<pre><code>WORKDIR /path/to/workdir
</code></pre><p>WORKDIR是用来切换当前工作目录的指令。切换后的路径影响后续的指令中的路径。<br>WORKDIR可以在Dockerfile出现多次,但最终生效的路径是所有WORKDIR指定的路径的叠加。<br>如果需要切换到其他的工作目录,那么应该使用全路径进行切换。如果使用相对路径,默认在当前目录中切换。<br>在WORKDIR中只可以使用ENV设定的环境变量值</p>
<pre><code>ENV DIRPATH /path
WORKDIR $DIRPATH/$DIRNAME
</code></pre><p>结果为/path/$DIRNAME</p>
<p><strong>ONBUILD 配置构建触发指令集,可选填</strong><br>由ONBUILD创建的触发命令集在当前Dockerfile执行过程中不会执行,而当此镜像被其他镜像当作其他镜像当作基础镜像使用时,将会被执行。</p>
<p>Dockerfile1</p>
<pre><code>FROM tomcat:7.0.72-jre7
MAINTAINER WSZ
ADD build_image_share /build_image_share
RUN [&quot;chmod&quot;,&quot;+x&quot;, &quot;/build_image_share&quot;]

LABEL &quot;description&quot;=&quot;just for test&quot; &quot;version&quot;=&quot;1.0&quot;
ENV myName=&quot;Shengzhi Wang&quot; mySoft=&quot;Docker image build&quot;


RUN mkdir /myvolume
RUN echo &quot;hello world&quot; &gt; /myvolume/greeting
VOLUME /myvolume

CMD echo &quot;This is a test&quot; | wc -
EXPOSE 8080
CMD［&quot;catalina.sh&quot;,&quot;run&quot;］
</code></pre><p>Dockerfile2</p>
<pre><code>FROM tomcat:7.0.72-jre7
MAINTAINER WSZ

ADD build_image_share /build_image_share
RUN [&quot;chmod&quot;,&quot;+x&quot;, &quot;/build_image_share&quot;]

WORKDIR /usr/local/tomcat/webapps
RUN rm -rf ROOT
WORKDIR /usr/local/tomcat/conf/Catalina/localhost
RUN echo &quot;&lt;?xml version=&apos;1.0&apos; encoding=&apos;utf-8&apos;?&gt;&quot; &gt; ROOT.xml 
RUN echo &quot;&lt;Context path=&apos;/show_books&apos; docBase=&apos;/build_image_share/show_books_base_on_angularJS_Underscore_master&apos; debug=&apos;0&apos; privileged=&apos;true&apos; reloadable=&apos;true&apos;/&gt; &quot; &gt;&gt; ROOT.xml
# RUN echo &quot;&lt;Context path=&apos;/shoppingweb&apos; docBase=&apos;/build_image_share/shoppingweb&apos; debug=&apos;0&apos; privileged=&apos;true&apos; reloadable=&apos;true&apos;/&gt; &quot; &gt;&gt; ROOT.xml

LABEL &quot;description&quot;=&quot;just for test&quot; &quot;version&quot;=&quot;1.0&quot;
ENV myName=&quot;Shengzhi Wang&quot; mySoft=&quot;Docker image build&quot;

CMD /usr/local/tomcat/bin/catalina.sh run
</code></pre><p>build_image_share里面有一个命名为show_books_base_on_angularJS_Underscore_master的war包,只有网页没有集成数据库。<br>然后在同目录下运行docker build -t showbooks .<br>生成镜像后运行docker run -d -p 8888:8080 showbooks<br>在本机访问localhost:8080查看结果</p>
<p>Dockerfile3              </p>
<pre><code>FROM tomcat:7.0.72-jre7
MAINTAINER WSZ

ADD build_image_share /build_image_share
RUN [&quot;chmod&quot;,&quot;+x&quot;, &quot;/build_image_share&quot;]

WORKDIR /usr/local/tomcat/webapps
RUN cp /build_image_share/shoppingweb.war shoppingweb.war

WORKDIR /usr/local/tomcat/conf
RUN sed -i~ &apos;/&lt;\/Host/i &lt;Context path=&quot;/&quot; docBase=&quot;shoppingweb.war&quot; debug=&quot;0&quot; privileged=&quot;true&quot; reloadable=&quot;true&quot;/&gt;&apos; server.xml

CMD /usr/local/tomcat/bin/catalina.sh run
</code></pre><h2 id="Dockerfile-优化方案"><a href="#Dockerfile-优化方案" class="headerlink" title="Dockerfile 优化方案"></a>Dockerfile 优化方案</h2><p>1.容器要尽可能短小精悍,在写Dockerfile之前确定容器要提供的服务,要可以快速的启动和停止,同时用最少的步骤来配置容器服务。<br>2.多使用.Dockerignore文件,当加载文件时过滤某些文件。<br>    当Docker加载文件时,如果发现目录存在.Dockerignore文件,那么此目录中符合.Dockerignore文件中定义规则的文件将会被过滤掉,不会被加载到缓存中。<br>    ./Dockerfile文件必须放到Dockerfile所在目录下面。./Dockerfile文件中的路径是以./Dockerfile所在目录为起点的。<br>3.不要安装非必需的软件包<br>4.一个容器尽量只运行一种服务<br>    为了达到容器可以快速部署的目的,应该尽量每个容器只对外提供一种服务。当容器需要其他服务时,通过link的方式从其他容器获取服务,而不是在当前容器再启动另外一种服务。<br>5.控制文件层数量<br>    文件层过多时,创建容器将会耗费更多的时间。<br>    可以将相似的命令放到同一个RUN指令中运行,以减少文件层数量。但是命令合并的太厉害,会影响到Dockerfile中RUN指令的可读性,导致Dockerfile的维护成本很高。<br>    要在文件层数量和可维护性之间找到平衡。<br>6.对命令中的参数进行排序</p>
<pre><code>RUN apt-get update &amp;&amp; apt-get install -y \
    bzr \
    cvs \
    git \
    subversion
</code></pre><p>对参数排序以后,可以避免下载重复的软件包,同时增添软件包时更为容易和控制,提高Dockerfile的可读性和可维护性。<br>默认规则,每行最后加空格和\<br>7.尽可能多使用缓存中的数据<br>    在Dockerfile执行过程中,Docker会讲某些命令的执行结果保存成临时镜像,保存在缓存中。在下次执行Dockerfile时,Docker会在执行每一条指令之前检测此条指令缓存值是否有效。只有当缓存没有或者缓存失效时,才会再次执行此条指令。<br>    若是不希望使用缓存中的结果,通过–no-cache=true来关闭此项功能。<br>    Docker加载完基础镜像之后,会对比由此基础镜像所派生出来的所有子镜像。对比规则就是看这些子镜像是否由Dockerfile后面的命令所创建的,如果后面的命令发生了变化,那么缓存自动失效。<br>    单纯的比较指令是否发生变化来判定缓存是否有效。ADD和COPY命令会检查其所涉及的文件是否发生了变更,标准是计算文件的校验和,而且只是校验镜像中的数据,不校验容器中的数据。<br>    一旦缓存的镜像失效,那么此缓存镜像以后的所有镜像都自动失效。</p>
<h2 id="某些命令"><a href="#某些命令" class="headerlink" title="某些命令"></a>某些命令</h2><p><strong>Delete all stopped containers</strong><br>docker rm $( docker ps -q -f status=exited)<br><strong>Delete all dangling (unused) images</strong><br>docker rmi $( docker images -q -f dangling=true)<br><strong>安装mysql server</strong><br>RUN apt-get update \<br>        &amp;&amp; apt-get install -y mysql-server<br><strong>mysql server启动</strong><br>docker run –name my-container-name -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql/mysql-server:tag<br><strong>重启mysql service</strong><br>service mysql restart<br>mysql -u root -p</p>
<p><strong>在容器外进入mysql</strong><br>docker exec -it mysql mysql -uroot -p<br><strong>加一个目录存数据</strong><br>docker run –name mysql2 -v /Users/szwang/DockerForMe/build_image/init_data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql/mysql-server</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>基于原先做的Shoppingweb项目,数据库是Mysql<br>修改root-context.xml相关的数据库的内容</p>
<pre><code>&lt;bean id=&quot;dataSource&quot;
            class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
            &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;
            &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://mysql:3306/shoppingdb?useUnicode=true&amp;amp;characterEncoding=UTF-8&quot; /&gt;
            &lt;property name=&quot;username&quot; value=&quot;shop&quot; /&gt;
            &lt;property name=&quot;password&quot; value=&quot;123456&quot; /&gt;
&lt;/bean&gt;
</code></pre><p>Dockerfile文件的内容如下:</p>
<pre><code>FROM tomcat:7.0.72-jre7
MAINTAINER WSZ

ADD build_image_share /build_image_share
RUN [&quot;chmod&quot;,&quot;+x&quot;, &quot;/build_image_share&quot;]

WORKDIR /usr/local/tomcat/webapps
RUN cp /build_image_share/shoppingweb.war shoppingweb.war

WORKDIR /usr/local/tomcat/conf
RUN sed -i~ &apos;/&lt;\/Host/i &lt;Context path=&quot;/&quot; docBase=&quot;shoppingweb.war&quot; debug=&quot;0&quot; privileged=&quot;true&quot; reloadable=&quot;true&quot;/&gt;&apos; server.xml

CMD /usr/local/tomcat/bin/catalina.sh run
</code></pre><p>template_envfile的内容如下:</p>
<pre><code>MYSQL_ROOT_PASSWORD=123456
MYSQL_ROOT_HOST=mysql
MYSQL_DATABASE=shoppingdb
MYSQL_USER=shop
MYSQL_PASSWORD=123456
</code></pre><p>在命令行里跑<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#下载mysql server</span></div><div class="line">docker pull mysql/mysql-server</div><div class="line"><span class="comment">#跑起一个数据库容器,root密码设置为123456,数据库的host设置为mysql,数据库名为shoppingdb,数据库用户名和密码为shop和123456</span></div><div class="line">docker run --name mysql2 --env-file ./template_envfile <span class="_">-d</span> mysql/mysql-server</div><div class="line"><span class="comment">#一样的效果</span></div><div class="line"><span class="comment">#docker run --name mysql -e MYSQL_ROOT_PASSWORD=123456 -e MYSQL_ROOT_HOST=mysql -e MYSQL_DATABASE=shoppingdb -e MYSQL_USER=shop -e MYSQL_PASSWORD=123456  -d mysql/mysql-server</span></div><div class="line"></div><div class="line"><span class="comment">#进入mysql容器,初始化数据库</span></div><div class="line">docker <span class="built_in">exec</span> -it mysql mysql -uroot -p</div><div class="line"><span class="comment">#如果Access denied失败,则运行docker exec -it mysql2 bash,在容器内运行mysql -u root -p</span></div><div class="line"><span class="comment">#运行sql文件</span></div><div class="line"></div><div class="line"><span class="comment">#启动运行应用的容器</span></div><div class="line">docker run --name shoppingwithlinkmysqlserver <span class="_">-d</span> -p 8080:8080 --env-file ./template_envfile --link mysql:mysql shoppingweb:2.0</div><div class="line"><span class="comment">#一样的效果</span></div><div class="line"><span class="comment">#docker run --name shoppingwithlinkmysqlserver -p 8080:8080 -d -e MYSQL_ROOT_PASSWORD=123456 -e MYSQL_ROOT_HOST=mysql -e MYSQL_DATABASE=shoppingdb -e MYSQL_USER=shop -e MYSQL_PASSWORD=123456 --link mysql:mysql shoppingweb:2.0</span></div></pre></td></tr></table></figure></p>
<p>参考书籍<br>《Docker 全攻略》张涛著   该本书有很长的篇幅介绍docker的命令<br><a href="https://docs.docker.com/" target="_blank" rel="external">《Docker 官方文档》</a><br><a href="https://hub.docker.com/r/mysql/mysql-server/" target="_blank" rel="external">mysql/mysql-server in Docker</a><br><a href="http://blog.awolski.com/using-docker-to-spin-up-databases-for-development/" target="_blank" rel="external">Using Docker to spin up databases for development</a><br><a href="http://txt.fliglio.com/2013/11/creating-a-mysql-docker-container/" target="_blank" rel="external">Creating a MySQL Docker Container</a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/11/28/Docker-learn3/" class="archive-article-date">
  	<time datetime="2016-11-28T06:30:41.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-11-28</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Docker/">Docker</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/technical/">technical</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-Docker-learn-first" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/17/Docker-learn-first/">Docker 学习笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Docker是什么"><a href="#Docker是什么" class="headerlink" title="Docker是什么"></a>Docker是什么</h2><p>Docker是一个开放源代码软件专案，让应用程序布署在软件容器下的工作可以自动化进行，借此在Linux操作系统上，提供一个额外的软件抽象层，以及操作系统层虚拟化的自动管理机制。<br>Docker目标是实现轻量级的操作系统虚拟化解决方案。减少软件开发周期中最繁琐、最耗时的环境准备环节。<br>Docker满足了免费的、轻量级、可移植、虚拟化、资源隔离、数据统一、语言无关、封装后的镜像可以随处部署和迁移这些要求。</p>
<h2 id="Docker优点"><a href="#Docker优点" class="headerlink" title="Docker优点"></a>Docker优点</h2><p>0）启动可以在秒级实现，比传统的虚拟机快很多<br>1）Docker的资源利用率比传统虚拟机要高，一台主机上可以同时运行数千个Docker容器<br>2）除了运行其中的应用，基本不消耗额外的系统资源，使得应用性能很高，同时系统开销小。<br>（传统的虚拟机方式运行10个不同的应用要10个虚拟机，Docker只要启动10个隔离的应用即可）<br>3）更快速的交付和部署，一次创建或配置可以在任意地方正常运行<br>4）更高效的虚拟化，Docker容器是内核级的虚拟化，可以实现更高的性能和效率<br>5）Docker支持跨节点部署，使得更轻松的迁移和扩展，Docker容器可以在任意的平台上运行，包括物理机、虚拟机、公有云、私有云、个人电脑、服务器等。兼容性高，用户可以把一个应用程序从一个平台直接迁移到另一个平台。“一次构建，自由分发。”<br>6）更简单的管理，小的修改代替大量的更新工作，所有的修改都以增量的方式被分发和更新，实现自动化并且高效的管理。<br>7）版本可控,组件可复用。镜像之间不是相互隔离的，镜像之间可以产生松耦合的关系。镜像是多层文件的联合体，这些文件层通过不同的组合可以产生不同的镜像，每一个镜像都有标签，标签代表了唯一的镜像，通过标签可以回溯加载特定的镜像。<br>8）共享镜像，Docker是开源的，构建的镜像可以上传到Docker Hub上<br>9）轻量，Docker是基于Linux内核进行的虚拟化操作，所有的容器共享内核资源的。</p>
<h2 id="Docker缺点"><a href="#Docker缺点" class="headerlink" title="Docker缺点"></a>Docker缺点</h2><p>1)宿主资源没有完成做到隔离<br>2)Golang语言尚未成熟<br>3)Docker虽已经开源,但在在未来可能收费</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/11/17/Docker-learn-first/" class="archive-article-date">
  	<time datetime="2016-11-17T08:09:07.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-11-17</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Docker/">Docker</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/technical/">technical</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-mxgraph" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/14/mxgraph/">mxgraph</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="mxgraph"><a href="#mxgraph" class="headerlink" title="mxgraph"></a>mxgraph</h2><p>mxGraph是一套用于图表图形的显示交互的开发工具库。支持的技术有：Java JavaScript PHP .NET。</p>
<p>Java版本用于创建高性能的桌面应用程序。<br>JavaScript版本的mxGraph是一个JS绘图组件,适用于需要在网页中设计/编辑Workflow/BPM流程图、图表、网络图和普通图形的Web应用程序,即主要用在所有的工作于网页浏览器本身的应用。</p>
<p>JavaScript版本主要技术优势:<br>    不需要第三方插件。<br>    涉及的技术是开放的。<br>    标准化的技术，应用程序可以轻松部署到最大数量的浏览器用户，而不需要在用户端的电脑进行额外的配置或安装。<br>JavaScript版本主要技术劣势：<br>    渲染速度。当用户屏幕上可见的单元数量攀升到数百时，在大多数浏览器上重绘减缓到超出可接受的水平。 在信息管理理论中，同时显示数百个单元通常是不正确的，因为用户无法一下子理解这么多的数据。有几种方法， 我们统称为复杂性管理机制，可以用来限制信息的数量，达到合理水平，从而保持可接受的重绘率。 复杂性管理在本用户手册后面的章节中有详细描述。</p>
<p>下载地址： <a href="http://www.jgraph.com/mxdownload.html" target="_blank" rel="external">http://www.jgraph.com/mxdownload.html</a><br>中文手册： <a href="http://www.mxgraph.cn/doc/mxgraph" target="_blank" rel="external">http://www.mxgraph.cn/doc/mxgraph</a> </p>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>在HTML页面加载mxGraph核心js文件即可使用mxGraph所有功能，几乎所有的js工具库都是这样使用的（JQuery ExtJs…）。 </p>
<p>下载mxGraph并解压<br><a href="https://github.com/jgraph/mxgraph/releases/tag/v3.6.0.0" target="_blank" rel="external">https://github.com/jgraph/mxgraph/releases/tag/v3.6.0.0</a></p>
<p>mxGraph/javascript/src 目录下包含了开发mxGraph项目所需要的所有东西,复制一份到项目中并指定正确的路径即可使用 </p>
<p>PS : 当显示的元素数量增多到上百个时， mxGraph的渲染速度会相当的缓慢。这将使用复杂性管理机制来解决。</p>
<h2 id="mxgraph的包"><a href="#mxgraph的包" class="headerlink" title="mxgraph的包"></a>mxgraph的包</h2><p>JavaScript的版本分成8个package。顶层是 mxClient 类。<br>editor package 提供实现图表编辑器所需的类在这个包中的主类是mxEditor。</p>
<p>view and model packages 实现图形组件, mxGraph. 它指的是一个 mxGraphModel包含 mxCells和 缓存 mxGraphView的cells状态.<br>handler, layout and shape packages 包含事件监听器、布局算法和形状, 事件监听器包括 mxRubberband for rubberband selection, mxTooltipHandler for tooltips and mxGraphHandler for basic cell modifications.  mxCompactTreeLayout implements a tree layout algorithm, and the shape package provides various shapes, which are subclasses of mxShape.<br>util package 提供了实用工具类包括mxclipboard复制粘贴, <mxdatatransfer>拖放, mxConstants 键和值的样式, mxEvent and mxUtils 跨浏览器的事件处理和通用函数,mxResources 国际化 and mxLog 控制台输出。<br>io package 实现将JavaScript对象到XML的通用 mxObjectCodec 。 主类是 mxCodec.  mxCodecRegistry 是全球注册自定义的编解码器。</mxdatatransfer></p>
<h2 id="hello-world简单例子"><a href="#hello-world简单例子" class="headerlink" title="hello,world简单例子"></a>hello,world简单例子</h2><p>显示hello和world两个格子相连。</p>
<p>1)新建一个helloWorld.html文件<br>2)放入一个container用于装载mxGraph<br>3)检测浏览器支持与否<br>4)画图</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></div><div class="line">        mxBasePath = 'src/';</div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"src/js/mxClient.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></div><div class="line">    function main(container) &#123;</div><div class="line">        // 检查浏览器支持</div><div class="line">        if (!mxClient.isBrowserSupported()) &#123;</div><div class="line">            mxUtils.error('Browser is not supported!', 200, false);</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            // 在指定容器中创建图形</div><div class="line">            var model = new mxGraphModel();</div><div class="line">            var graph = new mxGraph(container, model);</div><div class="line">            // 激活橡皮圈选择</div><div class="line">            new mxRubberband(graph);</div><div class="line">            // 拿到插入单元的默认父节点。</div><div class="line">            // 这通常是根节点的第一子节点（如0层）。</div><div class="line">            var parent = graph.getDefaultParent();</div><div class="line">            // 在一个步骤中，加入所有的单元到模型中</div><div class="line">            model.beginUpdate();</div><div class="line">            try &#123;</div><div class="line">                var v1 = graph.insertVertex(parent, null,</div><div class="line">                        'Hello', 20, 20, 80, 30);</div><div class="line">                var v2 = graph.insertVertex(parent, null,</div><div class="line">                        'World', 200, 150, 80, 30);</div><div class="line">                var e1 = graph.insertEdge(parent, null, '', v1, v2);</div><div class="line">            &#125;</div><div class="line">            finally &#123;</div><div class="line">                // 更新显示</div><div class="line">                model.endUpdate();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 页面传递图形的容器给程序 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">"main(document.getElementById('container'))"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>在script中的mxBasePath:<br>    一个JavaScript变量，用来定义CSS,图片,资源和js的使用的目录。是一段JavaScript代码,并需要被放置在脚本标记内。 它必须在加载mxClient.js之前,而且不应该斜线。</p>
<p>mxClient.js<br>    这是mxGraph库的路径。</p>
<p>onload=”main(document.getElementById(‘container’))”<br>    创建容器,onload加载网页时会被调用。它通过在传递即下定义的一个div 容器作为参数。<br>    mxGraph组件将被放置在这个div容器中。</p>
<p>mxClient.isBrowserSupported()<br>    任何mxGraph应用程序的第一行应该检查浏览器的支持，如果不支持应该适当退出。如果浏览器支持， mxGraph将在div容器内被创建，在开始/结束更新调用之间，三个单元被添加到图形中。</p>
<h2 id="部分方法"><a href="#部分方法" class="headerlink" title="部分方法"></a>部分方法</h2><p>// 无效<br>graph.setEnabled(false);</p>
<p>// 连接<br>graph.setConnectable(true);</p>
<p>// 提示信息<br>graph.setTooltips(true);</p>
<p>// 右键移动容器坐标轴<br>graph.setPanning(true);</p>
<p>// 容器大小自适应<br>graph.setResizeContainer(true);</p>
<p>// 使用浏览器默认的按键监听<br>new mxRubberband(graph);</p>
<p>// 动态改变样式<br>graph.getView().updateStyle = true;</p>
<p>// 重复连接<br>graph.setMultigraph(false);</p>
<p>// Label 将显示 Html 格式的 Value<br>graph.setHtmlLabels(true);</p>
<p>// 禁用浏览器默认的右键菜单栏<br>mxEvent.disableContextMenu(container);</p>
<p>// 允许移动 Vertex 的 Label<br>graph.setVertexLabelsMovable(true);</p>
<p>// 禁止改变元素大小<br>graph.setCellsResizable(false);</p>
<p>// 允许连线的目标和源是同一元素<br>graph.setAllowLoops(true);</p>
<p>//选中所有的线<br>raph.selectEdges();</p>
<p>//使线在所有元素的底下<br>graph.orderCells(true);</p>
<p>//取消选中的元素<br>graph.clearSelection();</p>
<p>——节点样式设置<br>1、如何设节点颜色？<br>通过属性fillColor（填充色）、gradientColor（渐变色），设为一样的颜色就是节点颜色了。<br>2、如何设置透明颜色？<br>在配置文件中none可设为默认颜色，transparent可设透明颜色<br>3、节点不可改变大小<br>0否，1是<br>4、节点与连线紧密连接，无空隙</p>
<p>5、节点颜色渐变方向？</p>
<p>6、如果不用配置文件？<br>你可以通过cell.setStyle(“XXXX”) 来实现样式的动态设置。<br>XXX形如：”样式属性=属性值;样式属性2=属性值2；”，可通过mxGraph官方doc搜索mxConstants来查找你需要的属性。<br>若设定选中节点的样式，还可通过graph.setCellStyles(mxConstants.属性,mxConstants.属性值);来设定该节点的样式。如：graph.setCellStyles(mxConstants.STYLE_GRADIENT_DIRECTION,mxConstants.DIRECTION_NORTH);<br>参考资料<br><a href="http://www.longboo.com/docs/mxGraph_jiaochen.htm" target="_blank" rel="external">mxGraph 教程1 - 开发入门指南</a><br><a href="http://www.mxgraph.cn/doc/mxgraph/" target="_blank" rel="external">mxGraph 用户手册 – JavaScript客户端</a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/11/14/mxgraph/" class="archive-article-date">
  	<time datetime="2016-11-14T02:17:26.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-11-14</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/technical/">technical</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-Docker-Learn" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/13/Docker-Learn/">Docker 学习笔记(一)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h1><p><a href="https://docs.docker.com/docker-for-mac/" target="_blank" rel="external">Mac 安装地址</a><br>关于在Ubuntu、CentOS和Debian系统安装Docker,<a href="https://www.gitbook.com/book/yeasy/docker_practice/details" target="_blank" rel="external">Docker —— 从入门到实践</a>书里有安装教程<br>其他系统安装Docker,参考<a href="https://docs.docker.com/engine/installation/" target="_blank" rel="external">官网</a></p>
<h2 id="Boot2Docker"><a href="#Boot2Docker" class="headerlink" title="Boot2Docker"></a>Boot2Docker</h2><p>Boot2Docker 是一个包含了 VirtualBox 虚拟软件、Docker 程序和Boot2Docker Management Tool的一个集合软件。Boot2Docker Management Tool是一个运行在Mac系统上的轻量级Linux虚拟机。<br>这个轻量级虚拟机完全运行在内存中,启动很快,体积很小。<br>通过Boot2Docker安装的Docker相当于运行在一个 VirtualBox 虚拟机中,而客户端运行在Mac OS 上。<br>(Mac直接安装Docker,不通过Boot2Docker安装感觉起来没什么区别啊?)</p>
<h1 id="Docker-三大组件"><a href="#Docker-三大组件" class="headerlink" title="Docker 三大组件"></a>Docker 三大组件</h1><p>仓库<br>镜像<br>容器</p>
<h1 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h1><p>Docker 官方维护了一个公共仓库<a href="https://hub.docker.com/" target="_blank" rel="external">Docker Hub</a></p>
<h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p>本地命令:docker login<br>会有提示输入用户名和密码,一次登录后,会记住登录信息。本地用户目录的 .dockercfg 中将保存用户的认证信息。</p>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p>命令为docker search 命令来查找官方仓库中的镜像，并利用docker pull 命令来将它下载到本地。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker search centos -s 3</div></pre></td></tr></table></figure></p>
<p>-s N(仅显示评价为 N 星以上的镜像)<br>下载命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker pull centos</div></pre></td></tr></table></figure></p>
<h2 id="私有仓库配置"><a href="#私有仓库配置" class="headerlink" title="私有仓库配置"></a>私有仓库配置</h2><p>参考书籍<a href="https://www.gitbook.com/book/yeasy/docker_practice/details" target="_blank" rel="external">Docker —— 从入门到实践</a></p>
<h1 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h1><h2 id="Docker-镜像分层"><a href="#Docker-镜像分层" class="headerlink" title="Docker 镜像分层"></a>Docker 镜像分层</h2><p>有3层,分别为:<br>  基础镜像<br>  中间件镜像<br>  应用镜像</p>
<h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker pull 镜像版本</div></pre></td></tr></table></figure>
<p>将从 Docker Hub 仓库下载一个符合要求的镜像<br>完整的命令为:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker pull registry.hub.docker.com/ubuntu:12.04</div></pre></td></tr></table></figure></p>
<p>即从注册服务器registry.hub.docker.com 中的 ubuntu 仓库来下载标记为 12.04 的镜像。</p>
<h2 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h2><p>下载镜像完成后，可以使用该镜像了，摘自书中的例子:创建一个容器，让其中运行 bash 应用。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker run -t -i ubuntu:12.04 /bin/bash</div></pre></td></tr></table></figure></p>
<h4 id="显示本地已有的镜像"><a href="#显示本地已有的镜像" class="headerlink" title="显示本地已有的镜像"></a>显示本地已有的镜像</h4><p>命令:docker images </p>
<h4 id="修改镜像"><a href="#修改镜像" class="headerlink" title="修改镜像:"></a>修改镜像:</h4><p><strong>1.docker commit 来扩展一个镜像</strong><br>镜像启动容器:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker run -t -i ubuntu:12.04 /bin/bash</div></pre></td></tr></table></figure></p>
<p> -t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， -i 则让容器的标准输入保持打开</p>
<p>在容器中添加json package:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">root@0b2616b0e5a8:/# gem install json</div></pre></td></tr></table></figure></p>
<p>退出: exit<br>提交更新后的副本:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo docker commit -m &quot;Added json gem&quot; -a &quot;Docker Newbee&quot; 0b2616b0e5a8 ouruser/sinatra:v2</div></pre></td></tr></table></figure></p>
<p>ouruser/sinatra:v2为目标镜像的仓库名和 tag 信息,如v2<br></p>
<p><strong>2.docker build 来创建一个新的镜像</strong><br>新建一个文件Dockerfile,里面的每一条指令都创建镜像的一层。<br></p>
<p>Dockerfile 基本的语法是:<br>    使用 # 来注释<br>    FROM 指令告诉 Docker 使用哪个镜像作为基础<br>    接着是维护者的信息<br>    RUN 开头的指令会在创建中运行，比如安装一个软件包，在这里使用 apt-get来安装了一些软件<br></p>
<p>编写完成 Dockerfile 后可以使用 docker build 来生成镜像。例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker build -t ouruser/sinatra:v2 .</div></pre></td></tr></table></figure></p>
<p>其中 -t 标记来添加 tag，指定新的镜像的用户信息。 “.” 是 Dockerfile 所在的路径（当前目录），也可以替换为一个具体的 Dockerfile 的路径。</p>
<h4 id="改变镜像标签内容"><a href="#改变镜像标签内容" class="headerlink" title="改变镜像标签内容"></a>改变镜像标签内容</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker tag 5db5f8471261 ouruser/sinatra:devel #5db...是镜像ID  后面的是修改后的标签</div></pre></td></tr></table></figure>
<h4 id="本地导入镜像"><a href="#本地导入镜像" class="headerlink" title="本地导入镜像:"></a>本地导入镜像:</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo cat ubuntu-14.04-x86_64-minimal.tar.gz |docker import - ubuntu:14.04</div></pre></td></tr></table></figure>
<h4 id="镜像上传到远程仓库"><a href="#镜像上传到远程仓库" class="headerlink" title="镜像上传到远程仓库:"></a>镜像上传到远程仓库:</h4><p>Docker Hub 上完成注册后，可以推送自己的镜像到仓库中<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker push ouruser/sinatra</div></pre></td></tr></table></figure></p>
<h4 id="保存镜像到本地文件"><a href="#保存镜像到本地文件" class="headerlink" title="保存镜像到本地文件:"></a>保存镜像到本地文件:</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker save -o ubuntu_14.04.tar ubuntu:14.04</div></pre></td></tr></table></figure>
<h4 id="从导出的本地文件中再加载到本地镜像库"><a href="#从导出的本地文件中再加载到本地镜像库" class="headerlink" title="从导出的本地文件中再加载到本地镜像库:"></a>从导出的本地文件中再加载到本地镜像库:</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ sudo docker load --input ubuntu_14.04.tar</div><div class="line">或</div><div class="line">$ sudo docker load &lt; ubuntu_14.04.tar</div></pre></td></tr></table></figure>
<h4 id="移除镜像"><a href="#移除镜像" class="headerlink" title="移除镜像"></a>移除镜像</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rmi training/sinatra</div></pre></td></tr></table></figure>
<p>在删除镜像之前要先用 docker rm 删掉依赖于这个镜像的所有容器。</p>
<p>清理所有未打过标签的本地镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo docker rmi $(docker images -q -f &quot;dangling=true&quot;)</div><div class="line">sudo docker rmi $(docker images --quiet --filter &quot;dangling=true&quot;)</div></pre></td></tr></table></figure></p>
<h1 id="Docker-容器"><a href="#Docker-容器" class="headerlink" title="Docker 容器"></a>Docker 容器</h1><p>容器是独立运行的一个或一组应用，以及它们的运行态环境。</p>
<h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><p>有两种方式:<br>1.基于镜像新建一个容器并启动<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker run -t -i ubuntu:12.04 /bin/bash</div></pre></td></tr></table></figure></p>
<p>使用docker run 来创建容器时，Docker 在后台运行的标准操作包括：</p>
<ul>
<li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li>
<li>利用镜像创建并启动一个容器</li>
<li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li>
<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>
<li>从地址池配置一个 ip 地址给容器</li>
<li>执行用户指定的应用程序</li>
<li>执行完毕后容器被终止</li>
</ul>
<p>2.将在终止状态（stopped）的容器重新启动<br>docker start命令，直接将一个已经终止的容器启动运行。可以利用 ps 或 top 来查看当前的进程信息。</p>
<h2 id="查看容器信息"><a href="#查看容器信息" class="headerlink" title="查看容器信息"></a>查看容器信息</h2><p>命令:docker ps<br>可以查看所有的容器及进程</p>
<h2 id="容器在后台运行"><a href="#容器在后台运行" class="headerlink" title="容器在后台运行"></a>容器在后台运行</h2><p>普通的docker run命令会在当前宿主机输出结果。<br>加上-d,此时容器会在后台运行并不会把输出的结果打印到宿主机上面,而是返回一个ID。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo docker run -d ubuntu:14.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</div></pre></td></tr></table></figure>
<p>查看输出结果可以用docker logs<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker logs [container ID or NAMES]</div></pre></td></tr></table></figure></p>
<p>里面可以是刚刚返回的ID也可以是NAME</p>
<h2 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h2><p>使用命令docker stop ID来终止</p>
<p>当Docker容器中指定的应用终结时，容器也自动终止。所以之前通过 exit 命令或 Ctrl+d 来退出终端时，所创建的容器立刻终止。<br>查看终止状态的容器可以用 docker ps -a命令。</p>
<h4 id="重启已经终止的容器"><a href="#重启已经终止的容器" class="headerlink" title="重启已经终止的容器"></a>重启已经终止的容器</h4><p>处于终止状态的容器，可以通过 docker start 命令来重新启动。<br>docker restart 命令会将一个运行态的容器终止，然后再重新启动它。</p>
<h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><p>当容器进入后台时,需要进入容器的操作<br>使用Attach命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker run -idt ubuntu <span class="comment">#后台运行</span></div><div class="line">docker ps <span class="comment">#查看进程</span></div><div class="line">docker attach 容器名或者ID</div></pre></td></tr></table></figure></p>
<p>使用nsenter 命令<br>nsenter工具在 util-linux 包2.23版本后包含,设备上没有的,需要手动安装。<br>详细步骤参考书籍<a href="https://www.gitbook.com/book/yeasy/docker_practice/details" target="_blank" rel="external">Docker —— 从入门到实践</a></p>
<h2 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h2><p>导出本地某个容器，使用 docker export 命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker export 容器ID &gt; ubuntu.tar(文件名)</div></pre></td></tr></table></figure></p>
<h2 id="导入容器"><a href="#导入容器" class="headerlink" title="导入容器"></a>导入容器</h2><p>使用docker import从容器快照文件中再导入为镜像:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ cat ubuntu.tar | docker import - <span class="built_in">test</span>/ubuntu:v1.0(镜像名和标签)</div><div class="line">$ docker images <span class="comment">#查看结果</span></div></pre></td></tr></table></figure></p>
<p>或者通过指定 URL 或者某个目录来导入，例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$sudo docker import http://example.com/exampleimage.tgz example/imagerepo</div></pre></td></tr></table></figure></p>
<p><strong>用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，<br>也可以使用 docker import 来导入一个容器快照到本地镜像库。<br>这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。<br>此外，从容器快照文件导入时可以重新指定标签等元数据信息。</strong></p>
<h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><p>使用 docker rm 来删除一个处于终止状态的容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$sudo docker rm trusting_newton</div></pre></td></tr></table></figure></p>
<p>如果要删除一个运行中的容器，可以添加 -f 参数。<br>清理所有处于终止状态的容器,使用以下命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rm $(docker ps -a -q)</div></pre></td></tr></table></figure></p>
<p>书籍:<br><a href="https://www.gitbook.com/book/yeasy/docker_practice/details" target="_blank" rel="external">Docker —— 从入门到实践</a>此处有电子书的下载途径</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/11/13/Docker-Learn/" class="archive-article-date">
  	<time datetime="2016-11-13T12:14:25.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-11-13</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Docker/">Docker</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/technical/">technical</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-Docker-Learn2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/13/Docker-Learn2/">Docker 学习笔记(二)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Docker中的某些命令详解"><a href="#Docker中的某些命令详解" class="headerlink" title="Docker中的某些命令详解"></a>Docker中的某些命令详解</h2><h4 id="logs-获取容器内部应用输出的日志-只能获取到重定向到STDOUT和STDERR的日志"><a href="#logs-获取容器内部应用输出的日志-只能获取到重定向到STDOUT和STDERR的日志" class="headerlink" title="logs 获取容器内部应用输出的日志,只能获取到重定向到STDOUT和STDERR的日志"></a>logs 获取容器内部应用输出的日志,只能获取到重定向到STDOUT和STDERR的日志</h4><h4 id="attach-挂载到正在运行的容器中-并且可以在容器中执行任何命令"><a href="#attach-挂载到正在运行的容器中-并且可以在容器中执行任何命令" class="headerlink" title="attach 挂载到正在运行的容器中,并且可以在容器中执行任何命令"></a>attach 挂载到正在运行的容器中,并且可以在容器中执行任何命令</h4><p>可以通过ID和name挂载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">➜  ~ docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</div><div class="line">6caf2b2b8d00        b1873e247b48        &quot;/bin/bash&quot;         32 minutes ago      Up 32 minutes                           reverent_thompson</div><div class="line">➜  ~ docker attach 6caf2b2b8d00</div><div class="line">root@6caf2b2b8d00:/#</div></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜  ~ docker attach reverent_thompson</div><div class="line">root@6caf2b2b8d00:/#</div></pre></td></tr></table></figure></p>
<p>通过Ctrl+P+Q来退出容器,容器还在运行中。<br>使用exit退出容器,容器同步被关闭。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">root@6caf2b2b8d00:/# exit 10</div><div class="line">➜  ~ docker ps -a |grep reverent_thompson</div><div class="line">6caf2b2b8d00        b1873e247b48         &quot;/bin/bash&quot;              52 minutes ago      Exited (10) 45 seconds ago                       reverent_thompson</div></pre></td></tr></table></figure></p>
<p>Exited (10) 容器的退出响应码变成了10,即可以通过exit命令来指定容器退出码。</p>
<h4 id="commit-以某个容器为基础保存成一个新的image"><a href="#commit-以某个容器为基础保存成一个新的image" class="headerlink" title="commit 以某个容器为基础保存成一个新的image"></a>commit 以某个容器为基础保存成一个新的image</h4><p>-a, –author=””这个参数的目标是保存新的作者。<br>-c, –change=[]这个参数保存的是修改image里面的配置参数。<br>目前支持的可以修改的配置参数有CMD|ENTRYPOINT|ENV|EXPOSE|LABEL|ONBUILD|USER|VOLUME|WORKDIR。其余的参数继承于上一个image<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜  ~ docker commit --change &quot;ENV DEBUG true&quot; 3af7938d2d31 svendowideit/testimage:version1</div><div class="line">sha256:c24a8c4cf76d9485e69fa4d975a6b8ccc3070dbf368a118672ab6a76a4249605</div></pre></td></tr></table></figure></p>
<p>3af7938d2d31是一个正在运行的容器,svendowideit/testimage是repository的名字,version1是tag的内容<br>查看结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜  ~ Docker inspect -f &quot;&#123;&#123; .Config.Env&#125;&#125;&quot; c24a8c4cf76d</div><div class="line">[DEBUG=true no_proxy=local PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin]</div></pre></td></tr></table></figure></p>
<p>-m, –message=””这个参数是提交一个comment备注信息,说明image的用途,修改的内容等信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">➜  ~  docker commit -m &quot;test message&quot; 3af7938d2d31 svendowideit/testimage:version2</div><div class="line">sha256:0d4f24b6a8d7d7239b9cfa163845c09866f30de9cc7ac23d48510e3ac095f6a4</div><div class="line">➜  ~ Docker inspect 0d4f24b6a8d7</div><div class="line">[</div><div class="line">    &#123;</div><div class="line">        &quot;Id&quot;: &quot;sha256:0d4f24b6a8d7d7239b9cfa163845c09866f30de9cc7ac23d48510e3ac095f6a4&quot;,</div><div class="line">        &quot;RepoTags&quot;: [</div><div class="line">            &quot;svendowideit/testimage:version2&quot;</div><div class="line">        ],</div><div class="line">        &quot;RepoDigests&quot;: [],</div><div class="line">        &quot;Parent&quot;: &quot;sha256:78a0e8d9b39cdcbb93d433ec5de61ba6c6d10369eccdf45b7e60318b47356d9a&quot;,</div><div class="line">        &quot;Comment&quot;: &quot;test message&quot;,</div><div class="line">        .........</div><div class="line">     &#125;</div><div class="line">]</div></pre></td></tr></table></figure></p>
<p>-p, –pause=true 默认情况下执行commit时,容器中所有进程处于暂停状态,如果此时容器对外提供服务,那其他容器会受到影响。<br>-pause=false使用这个参数使得在执行commit时保持容器内进程继续工作。但是commit效率会下降。</p>
<h4 id="create-创建容器"><a href="#create-创建容器" class="headerlink" title="create 创建容器"></a>create 创建容器</h4><p>create命令是以image为模板创建的一个容器,并且在容器文件的最上面一层添加一个读写层,容器里面的数据变化会被保存在读写层。<br>create成功后需要通过start来启动容器。<br>参数:<br>-i 将Host的Stdin和容器的Stdin相连接<br>-t 创建一个pty终端<br>(-it 前两者结合使用相当于在host环境中启动一个链接容器的pty伪终端,在host的pty中输入的数据就会传到容器之中。)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">➜  ~ docker create -it addwszfile bash</div><div class="line">7019c6b575fe673954f2019a99fb6679b7a2f4a604d324290ff5111c42feae2b</div><div class="line">➜  ~ docker create -it -v /dockerforme/sinatra/share_folder/:/tmp --name data1 addwszfile</div><div class="line">7cfc3205a8df843d1b7219a31f51976b5df638cb20a03c57134ec690da990875</div><div class="line">➜  ~ docker create -P --name data2 addwszfile</div></pre></td></tr></table></figure></p>
<p>addwszfile是image名称。</p>
<p>-p 映射网络端口,当应用需要访问其他应用或被访问,需要开放一个端口<br>-P 容器中所有需要暴露的端口都会映射到主机随机的一个端口(端口范围49153~65535)<br>-v 挂载参数,把主机的一个文件或者一个目录挂载到容器中</p>
<h4 id="diff-比较容器文件文件层数据差异的命令"><a href="#diff-比较容器文件文件层数据差异的命令" class="headerlink" title="diff 比较容器文件文件层数据差异的命令"></a>diff 比较容器文件文件层数据差异的命令</h4><p>首先启动一个容器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker run -t -i ubuntu:12.04 /bin/bash</div></pre></td></tr></table></figure></p>
<p>在容器中做某些操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">root@543f21cb4a4e:/# touch /tmp/wsz.txt</div><div class="line">root@543f21cb4a4e:/# echo &quot;This is wsz add test&quot; &gt; /tmp/wsz.txt</div><div class="line">root@543f21cb4a4e:/# touch /tmp/wsz2.txt</div><div class="line">root@543f21cb4a4e:/# rm /tmp/wsz2.txt</div><div class="line">root@543f21cb4a4e:/# touch /tmp/wsz3.txt</div><div class="line">root@543f21cb4a4e:/# echo &quot;This is a change test&quot; &gt; /tmp/wsz3.txt</div><div class="line">root@543f21cb4a4e:/# echo &quot;I add a new line&quot; &gt;&gt; /tmp/wsz3.txt</div></pre></td></tr></table></figure></p>
<p>新开一个命令行窗口,查看diff<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">➜  ~ docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</div><div class="line">543f21cb4a4e        ubuntu:12.04        &quot;/bin/bash&quot;         4 minutes ago       Up 4 minutes                            trusting_bell</div><div class="line">➜  ~ docker diff 543f21cb4a4e</div><div class="line">C /tmp</div><div class="line">A /tmp/wsz.txt</div><div class="line">A /tmp/wsz3.txt</div></pre></td></tr></table></figure></p>
<p>结果中的A表示add;C表示Change;D表示Delete<br>可以看见之中我们是创建一个wsz2.txt的文件然后又删除了,但是在diff中并没有反应出来,这是因为我们操作产生的数据保存在最上面的读写层里,diff比较的是最上层和其他层的差异,其中wsz2的文件不存在于其他层所以不显示。<br>若想时时刻刻保存状态,可以save读写层,再进行删除。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">➜  ~ docker commit 543f21cb4a4e addwszfile</div><div class="line">sha256:b1873e247b48d2ffb12725552691db3c8a2d1f097efdfbb04aeddb9cf13d8c9c</div><div class="line">➜  ~ docker run -it b1873e247b48d2ffb12725552691db3c8a2d1f097efdfbb04aeddb9cf13d8c9c</div><div class="line">root@6caf2b2b8d00:/# rm /tmp/wsz.txt</div></pre></td></tr></table></figure></p>
<p>新开一个命令行窗口可以看到删除的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">➜  ~ docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</div><div class="line">6caf2b2b8d00        b1873e247b48        &quot;/bin/bash&quot;         40 seconds ago      Up 39 seconds                           reverent_thompson</div><div class="line">➜  ~ docker diff 6caf2b2b8d00</div><div class="line">C /tmp</div><div class="line">D /tmp/wsz.txt</div></pre></td></tr></table></figure></p>
<h4 id="events-获取容器所报告的事件"><a href="#events-获取容器所报告的事件" class="headerlink" title="events 获取容器所报告的事件"></a>events 获取容器所报告的事件</h4><p>Docker容器再运行过程中会向Docker Daemon报告如下事件:<br>create、destroy、die、export、kill、oom、pause、start、stop、unpause<br>Image镜像会向Docker Daemon报告untag、delete事件<br>筛选的几种方式:<br>–since 指从某一个时间点开始Docker Daemon接收的所有事件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜  ~ docker events --since &apos;2016-09-01&apos;</div></pre></td></tr></table></figure></p>
<p>–until 需要和 –since结合使用,指的是从某一个时间点开始到某一个时间点结束。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜  ~ docker events --since &apos;2016-09-01&apos; --until &apos;2016-11-08T15:00:00&apos;</div></pre></td></tr></table></figure></p>
<p>–filter 接收的是key=value的键值对。目前有效的key是container、event、image。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">➜  ~ docker events --filter &apos;event=stop&apos;</div><div class="line">➜  ~ docker events --filter &apos;image=ubuntu:14.04&apos;</div><div class="line">➜  ~ docker events --filter &apos;container=543f21cb4a4e&apos;</div></pre></td></tr></table></figure></p>
<h4 id="exec-在容器中运行其他命令"><a href="#exec-在容器中运行其他命令" class="headerlink" title="exec 在容器中运行其他命令"></a>exec 在容器中运行其他命令</h4><p>执行ps删选进程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜  ~ docker exec 6caf2b2b8d00 ps -s|grep bash</div></pre></td></tr></table></figure></p>
<p>创建一个新文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜  ~ docker exec 6caf2b2b8d00 touch /tmp/1.txt</div></pre></td></tr></table></figure></p>
<p>修改文件,前提需要申请一个pty和绑定一个stdin用来保存编辑的文件,因为没有pty容器无法收到控制字符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜  ~ docker exec -it 6caf2b2b8d00 vi /tmp/1.txt</div></pre></td></tr></table></figure></p>
<h4 id="history-追踪image的历史记录"><a href="#history-追踪image的历史记录" class="headerlink" title="history 追踪image的历史记录"></a>history 追踪image的历史记录</h4><p>diff 查看的是容器中文件系统的变更历史。History查看的是image的变更历史。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜  ~ docker history ouruser/sinatra:v3</div></pre></td></tr></table></figure></p>
<p>-H,–human 表示是否输出方便用户识别的格式。<br>–no-trunc=false 默认false,表示将输出按照一定的格式进行截断。<br>–quiet 若是设置为true,只返回image构建过程中所有的临时文件层的image ID,为false时返回所有信息。</p>
<h4 id="info-显示Docker摘要信息"><a href="#info-显示Docker摘要信息" class="headerlink" title="info 显示Docker摘要信息"></a>info 显示Docker摘要信息</h4><p>info 指令显示Docker摘要信息,用来确认Docker信息。包含Docker内核版本号、Docker所设定的CPU、内存参数等环境底层信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜  ~ docker info</div></pre></td></tr></table></figure></p>
<h4 id="inspect-返回指定目标的底层信息"><a href="#inspect-返回指定目标的底层信息" class="headerlink" title="inspect 返回指定目标的底层信息"></a>inspect 返回指定目标的底层信息</h4><p>inspect可以返回image和container的底层信息。包括某个容器的IP地址,MAC地址,端口信息等等。<br>返回的几类信息:<br>1.基本信息类:名称,创建时间,当前状态(运行、停止、暂停)等<br>2.运行参数类:网络信息、环境变量、主机名称等<br>3.底层数据类:CPU设置、内存设置、虚拟化设置等<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker inspect -f &#123;&#123;要查看的参数名&#125;&#125; ID号</div><div class="line">docker inspect -f &apos;&#123;&#123;json .Config&#125;&#125;&apos; ID号</div><div class="line">docker inspect -f &apos;&#123;&#123;(index (index .Config &quot;Env&quot;) 0)&#125;&#125;&apos; ID号              取出Config中Env第一个元素命令</div></pre></td></tr></table></figure></p>
<p>json是指把数据格式化成json字符串<br>index取第几个</p>
<h4 id="kill-强制停止容器"><a href="#kill-强制停止容器" class="headerlink" title="kill 强制停止容器"></a>kill 强制停止容器</h4><p>一般使用stop关掉容器。出现异常使用kill<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker kill 容器名</div></pre></td></tr></table></figure></p>
<h4 id="ps-查看当前容器的运行状态"><a href="#ps-查看当前容器的运行状态" class="headerlink" title="ps 查看当前容器的运行状态"></a>ps 查看当前容器的运行状态</h4><h4 id="rename-对容器重命名"><a href="#rename-对容器重命名" class="headerlink" title="rename 对容器重命名"></a>rename 对容器重命名</h4><p>docker rename 旧名字 新名字</p>
<h4 id="tag-对镜像重命名"><a href="#tag-对镜像重命名" class="headerlink" title="tag 对镜像重命名"></a>tag 对镜像重命名</h4><p>……还有很多命令看文档</p>
<p>参考书籍<br>《Docker 全攻略》张涛著<br><a href="https://docs.docker.com/" target="_blank" rel="external">《Docker 官方文档》</a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/11/13/Docker-Learn2/" class="archive-article-date">
  	<time datetime="2016-11-13T12:14:25.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-11-13</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Docker/">Docker</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/technical/">technical</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-List-Task" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/02/List-Task/">任务分解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>对于一个程序媛来说,如何提高自己的开发效率,这一直都是我追寻的方法。直到最近才get到一个可以有所帮助的技能。</p>
<h2 id="任务分解-列Task"><a href="#任务分解-列Task" class="headerlink" title="任务分解,列Task"></a>任务分解,列Task</h2><p>当我们拿到一个任务卡片时,经常干的一件事,就是明确卡片中的要求和明细,然后就直接开始码代码了。因为写的代码是可见的,运行成功会有极大成就感,然而其实这并不是一个好的方式。</p>
<p>在我们写代码之前应该根据卡片内容,从开发的角度把一个大卡分解成各个小任务,然后针对每个小任务进行开发才是可取的。其实这种方法得到的成就感并不亚于前者。</p>
<h4 id="Task-是什么-如何列"><a href="#Task-是什么-如何列" class="headerlink" title="Task 是什么,如何列"></a>Task 是什么,如何列</h4><p>很多人会和我一样困惑,要列Task,但是什么是Task呢?一般来说,一个function(函数),一个Process或者一个Code Block(代码块)都可以是一个Task。<br>每一个Task都有相应的输入和输出。输入的可以是函数的参数,全局变量,局部变量(对于代码块来说)。输出可以是返回值,变量等。</p>
<p>每个Task的输入都是可穷尽的,在列Task的时候要列出所有用到的Task。<br>列Task的时候的命名要精确,每一个名字在不同的地方有不同的意思。</p>
<p>列Task,一般会画一个包含Data和Process的图。类似一个有架构的数据流向图。Data(数据)一般有数组、队列、栈、树、对象、类、有循环的对象等,Process(过程)一般有顺序的、选择的(if/switch)、循环(for/while)等。</p>
<p>参考<br><a href="https://www.zybuluo.com/jtong/note/504192" target="_blank" rel="external">编程的精进之法</a></p>
<h2 id="PDCA-戴明环"><a href="#PDCA-戴明环" class="headerlink" title="PDCA 戴明环"></a>PDCA 戴明环</h2><p>PDCA指的是Plan-Do-Check-Action,而列Task属于Plan的内容。</p>
<p>如何定义Done?<br>1.code Done<br>2.test pass<br>3.Integration env<br>4.showcase<br>5.production env<br>6.ux(用户使用)</p>
<p>单个任务的开发流程:0)Spike即调研;1)写测试;2)写实现;3)测试通过</p>
<h2 id="例子一-打印学生成绩单"><a href="#例子一-打印学生成绩单" class="headerlink" title="例子一,打印学生成绩单"></a>例子一,打印学生成绩单</h2><h4 id="背景"><a href="#背景" class="headerlink" title="背景:"></a>背景:</h4><p><a href="https://www.zybuluo.com/jtong/note/471501" target="_blank" rel="external">https://www.zybuluo.com/jtong/note/471501</a>  中的课后作业<br>打印所有人的成绩单,包括平均分和总分。<br>打印全班级的总分平均分和中位数。</p>
<h4 id="列Task"><a href="#列Task" class="headerlink" title="列Task"></a>列Task</h4><h5 id="1-转换ViewModel"><a href="#1-转换ViewModel" class="headerlink" title="1) 转换ViewModel"></a>1) 转换ViewModel</h5><p>输入:</p>
<pre><code>studentScoresArray:[[String]]
</code></pre><p>输出:</p>
<pre><code>studentScoresSheet:[{
    name:String,
    chinese:double,
    english:double,
    math:double,
    programming:double
    },
    {
    ...
    }]
</code></pre><h5 id="2-得到学生成绩"><a href="#2-得到学生成绩" class="headerlink" title="2) 得到学生成绩"></a>2) 得到学生成绩</h5><p>输入:</p>
<pre><code>studentScoresSheet
</code></pre><p>输出:</p>
<pre><code>studentScoresSheetWithSummary:[{
    name:String,
    chinese:double,
    english:double,
    math:double,
    programming:double,
    average:double,
    total:double
    },
    {
     ...
    }]
</code></pre><h5 id="3-计算总计"><a href="#3-计算总计" class="headerlink" title="3) 计算总计"></a>3) 计算总计</h5><p>输入:</p>
<pre><code>studentScoresSheetWithSummary
</code></pre><p>输出:</p>
<pre><code>summary:{
    totalAverage:double,
    totalMidden:double
    }
</code></pre><h5 id="4-打印成绩单"><a href="#4-打印成绩单" class="headerlink" title="4) 打印成绩单"></a>4) 打印成绩单</h5><p>输入:</p>
<pre><code>studentScoresSheetWithSummary
summary
</code></pre><p>输出:</p>
<pre><code>Result:String
</code></pre><p><a href="https://github.com/wszhi/TaskConsoleStudentScoreInfo" target="_blank" rel="external">Github代码</a></p>
<h2 id="例子二-猜数字游戏"><a href="#例子二-猜数字游戏" class="headerlink" title="例子二,猜数字游戏"></a>例子二,猜数字游戏</h2><p><a href="https://github.com/raypeng/guess-number-raypeng/blob/master/README.md" target="_blank" rel="external">具体游戏内容</a><br>这个游戏有几个需要注意点:<br>1)Compare(两个数字对比的前提假设:符合要求的、合法的值)<br>2)生成随机数(生成的数是数字、四位、每位都不一样)<br>3)游戏流程(进入游戏–第一次成功/中间成功/最后一次成功/游戏失败)</p>
<p>PS:不能放过任何一个逻辑冲突;等加类划分可以使用正交分解法;还要考虑系统状态怎么保持<br>正交分解法:</p>
<pre><code> \ 位   |         |         | 
  \ 置  |         |         |
数 \    | 全都一样 | 全不一样 | 部分一样
字  \   |         |         |
--------------------------------------
全都一样 | 4A0B    | 0A4B    | 2A4B
全不一样 | 不可能   | 0A0B    | 不可能
部分一样 | 不可能   | 0A2B    | 2A2B
</code></pre><p>分解后的图如下:<br>1)应用启动<br><img src="http://img.blog.csdn.net/20161107144603037" alt=""></p>
<p>2)界面1(按1启动游戏)<br><img src="http://img.blog.csdn.net/20161107144618709" alt=""></p>
<p><img src="http://img.blog.csdn.net/20161107144638756" alt=""></p>
<p>main是解决输入输出的。<br>Router通过输入输出解析找到具体的Command。<br>Command处理各种具体的用户输入,对Core层返回的结果翻译成友好的输出。<br>Core层函数生成计算结果。</p>
<p>3)退出(按2退出游戏)<br><img src="http://img.blog.csdn.net/20161107144657923" alt=""></p>
<h2 id="例子三-邮编和条码的转化"><a href="#例子三-邮编和条码的转化" class="headerlink" title="例子三,邮编和条码的转化"></a>例子三,邮编和条码的转化</h2><h2 id="例子四-一对多web基础应用"><a href="#例子四-一对多web基础应用" class="headerlink" title="例子四,一对多web基础应用"></a>例子四,一对多web基础应用</h2><h2 id="例子五-多对多web基础应用"><a href="#例子五-多对多web基础应用" class="headerlink" title="例子五,多对多web基础应用"></a>例子五,多对多web基础应用</h2>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/11/02/List-Task/" class="archive-article-date">
  	<time datetime="2016-11-02T07:26:15.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-11-02</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/technical/">technical</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-ansible" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/31/ansible/">ansible</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>因为项目需要,所以提前学习了一下ansible,ansible是一个配置管理工具。</p>
<h2 id="ansible-安装"><a href="#ansible-安装" class="headerlink" title="ansible 安装"></a>ansible 安装</h2><p>Mac OS X 上安装Ansible,如果已经有Homebrew包管理工具可以直接运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install ansible</div></pre></td></tr></table></figure></p>
<p>Python包管理工具pip安装,root 安装方式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo pip install ansible</div></pre></td></tr></table></figure></p>
<p>非root安装方式,可以安装到一个Python virtualenv中,或者使用pipsi工具,自动安装到Python virtualenv中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">wget https://raw.githubusercontent.com/mitsuhiko/pipsi/master/get-pipsi.py</div><div class="line">python get-pipsi.py</div><div class="line">pipsi install ansible</div></pre></td></tr></table></figure></p>
<p>再将~/.local/bin添加到Path环境变量中。</p>
<p>使用pip安装docker-py和boto<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd ~/.local/venvs/ansible</div><div class="line">source bin/actiivate</div><div class="line">pip install docker-py boto</div></pre></td></tr></table></figure></p>
<p>ps: 安装wget<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">cd Downloads</div><div class="line">curl -O http://ftp.gnu.org/gnu/wget/wget-1.14.tar.gz</div><div class="line">tar xvzf wget-1.14.tar.gz</div><div class="line">cd wget-1.14</div><div class="line">./configure --with-ssl=openssl</div><div class="line">make</div><div class="line">sudo make install</div></pre></td></tr></table></figure></p>
<p><a href="https://coolestguidesontheplanet.com/install-and-configure-wget-on-os-x/" target="_blank" rel="external">install wget in Mac OS X</a></p>
<p>参考<a href="https://valdhaus.co/writings/ansible-mac-osx/" target="_blank" rel="external">install ansible on Mac</a><br><a href="http://docs.ansible.com/ansible/intro_installation.html" target="_blank" rel="external">ansible官方安装文档</a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/10/31/ansible/" class="archive-article-date">
  	<time datetime="2016-10-31T06:43:38.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-10-31</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ansible/">ansible</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/technical/">technical</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-Software-Architecture" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/28/Software-Architecture/">架构设计</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近在接受一个培训,第一次接触了架构设计的知识,有些名词晦涩难懂,导致在这一块的学习还是有所欠缺。<br>尽管如此,在培训中和培训后的努力学习后,做了点整理,理解的可能有所偏差,欢迎拍砖。</p>
<p>架构设计对于一个项目来说十分重要。</p>
<h2 id="一份完整的架构设计应该包括哪些内容"><a href="#一份完整的架构设计应该包括哪些内容" class="headerlink" title="一份完整的架构设计应该包括哪些内容"></a>一份完整的架构设计应该包括哪些内容</h2><p>1）建模，提炼资源<br>2）系统结构（BFF，业务流程）<br>3）开发团队结构<br>4）可用性与性能架构<br>5）安全性架构<br>6）质量架构<br>7）部署架构<br>8）运维架构<br>9）技术选型</p>
<h2 id="面向行为的接口设计与面向资源的接口设计-ROA"><a href="#面向行为的接口设计与面向资源的接口设计-ROA" class="headerlink" title="面向行为的接口设计与面向资源的接口设计(ROA)"></a>面向行为的接口设计与面向资源的接口设计(ROA)</h2><p>面向行为的接口设计是建立在动词（行为）的基础之上的，系统要枚举所有的业务行为，如果行为发生改变，接口也随之改变。<br>面向资源的接口设计便于实施、设计灵活、是轻量级的对象访问方式。<br>面向资源的接口设计关注的是名词（资源），解决了在业务需求发生变化时要对代码做很大的改变的问题。</p>
<h2 id="SOA-面向服务的架构设计"><a href="#SOA-面向服务的架构设计" class="headerlink" title="SOA 面向服务的架构设计"></a>SOA 面向服务的架构设计</h2><p>将紧耦合的系统,划分为面向业务的,粗粒度,松耦合,无状态的服务。<br>目的是提高软件的重用性，减少开发和维护的成本，最终增加敏捷度。</p>
<h2 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h2><p>微服务架构其中的一个重点是业务系统需要彻底的组件化和服务化,原来的业务可以拆分成独立的系统应用进行开发,这些相互独立的系统应用通过服务完成交互和集成。<br>它的目的是有效的拆分应用,实现敏捷开发和部署,为构建应用提供更轻量级、更高效的开发。</p>
<p>微服务不再强调传统SOA架构里面比较重的<strong>ESB</strong>企业服务总线，同时SOA的思想进入到单个业务系统内部实现真正的组件化。</p>
<h4 id="微服务足够构成一个独立的小应用-从DB到UI"><a href="#微服务足够构成一个独立的小应用-从DB到UI" class="headerlink" title="微服务足够构成一个独立的小应用(从DB到UI)"></a>微服务足够构成一个独立的小应用(从DB到UI)</h4><p>微服务的基本思想在于考虑围绕着业务领域组件来创建应用,这些应用可以独立的进行开发管理和加速。在分散的组件中使用微服务云架构和平台使部署管理和服务功能交付变得更加简单。</p>
<p>(<strong>Devops</strong>:开发测试和部署运维一体化。)</p>
<p>把单体应用拆分成多个小应用后,整体架构可以松耦合和可扩展,但是当拆分的组件越多,这些组件之间本省的集成和部署运维就越复杂。<br>任何一个组件,当依赖的外部应用组件越多的时候,整个集成,部署和连调测试的过程就越复杂,所以自动化这个过程可以减少工作量和出错概率。</p>
<p>微服务架构首先要做好单个组件本身的持续集成,其次在这个基础上增加了多个组件的打包部署和组件间的集成。包括环境变量的配置,自动打包部署,自动化的测试等。</p>
<p>不像传统多个服务共享一个数据库,微服务架构每个服务都有自己的数据库。</p>
<h4 id="一般运行在云虚拟机或者更轻的Docker上"><a href="#一般运行在云虚拟机或者更轻的Docker上" class="headerlink" title="一般运行在云虚拟机或者更轻的Docker上"></a>一般运行在云虚拟机或者更轻的Docker上</h4><p>微服务架构强调了单个组件本身可以在独立的进程里面运行,各个组件之间在部署的时候就能够做到进程级别的隔离性。<br>为了保持进程的隔离性,使用虚拟机,但是几十个进程都完全用独立的虚拟机就不现实,解决方案为利用Docker容器,每个Docker是独立的容器,完全做到了进程季节的隔离,资源占用率最小,满足了微服务架构的开发测试和自动化部署。</p>
<h4 id="微服务应用之间只能通过Service-API进行交互"><a href="#微服务应用之间只能通过Service-API进行交互" class="headerlink" title="微服务应用之间只能通过Service API进行交互"></a>微服务应用之间只能通过Service API进行交互</h4><p>单个服务的实现和发布仍然在组件内部完成,但是需要一个统一的SOA服务管理平台来显示服务本身的调用情况,服务本身的安全,日志和流量控制。<br>微服务强调采用HTTP Rest API的方式。<br>即微服务尽量通过HTTP API的方式暴露出去,因此这种服务管理平台需要基本的服务注册,服务代理,服务发布,服务简单的路由,安全访问和授权,服务调用消息和日志记录功能。</p>
<h3 id="微服务架构的优势"><a href="#微服务架构的优势" class="headerlink" title="微服务架构的优势"></a>微服务架构的优势</h3><p>1.通过分解巨大单体式应用为多个服务方法解决了复杂性问题。在功能不变的情况下,应用被分解为多个可管理的分支或服务。单个服务很容易开发、理解和维护。<br>2.每个服务都可以有专门的开发团队并行开发。<br>3.每个服务独立部署,不需要协调其他服务部署对本服务的影响,加快了部署速度,使得持续化部署成为可能。<br>4.每个服务可独立扩展。<br>5.每个服务足够内聚，足够小，代码容易理解、开发效率提高。<br>7.提高容错性，一个服务的内存泄露并不会让整个系统瘫痪。<br>8.可以使用多个技术栈,系统不会被技术栈长期限制。</p>
<h3 id="微服务架构的不足"><a href="#微服务架构的不足" class="headerlink" title="微服务架构的不足"></a>微服务架构的不足</h3><p>1.一个应用系统里面的模块没有办法做到彻底解耦,无法实现组件单独部署,相互之间有大量内部不可见依赖而导致了模块间的无法拆分。<br>2.微服务应用式分布式系统,会带来固有的复杂性。<br>3.分区的数据库架构带来的挑战,因为需要更新不同服务所使用的不同的数据库。<br>4.测试一个基于微服务架构的应用很复杂。<br>5.微服务架构模式应用的改变将会波及多个服务。<br>6.部署一个微服务应用也很复杂，一个分布式应用只需要简单在复杂均衡器后面部署各自的服务器就好了。每个应用实例是需要配置诸如数据库和消息中间件等基础服务。</p>
<h3 id="微服务的特征"><a href="#微服务的特征" class="headerlink" title="微服务的特征:"></a>微服务的特征:</h3><p>通过服务实现组件化<br>按业务能力来划分服务于组织团队<br>服务即产品<br>智能终端与哑管道<br>去中心统一化<br>基础设施自动化<br>Design for failure<br>进化设计</p>
<h3 id="微服务总结"><a href="#微服务总结" class="headerlink" title="微服务总结"></a>微服务总结</h3><p>一个微服务一般完成某个特定的功能,每个微服务都是一个微型应用,有着自己的六边形架构,包括商业逻辑和各种接口。<br>有的微服务通过暴露API被别的微服务或者应用客户端所用;有的微服务则通过UI实现。在运行时,每个实力通常时一个云虚拟机或者Docker容器。</p>
<h2 id="SOA、微服务、服务化这几个概念的差别和关系"><a href="#SOA、微服务、服务化这几个概念的差别和关系" class="headerlink" title="SOA、微服务、服务化这几个概念的差别和关系"></a>SOA、微服务、服务化这几个概念的差别和关系</h2><p>SOA服务导向架构，将应用程序功能作为服务发送给最终用户或者其他服务，是整合各种业务的应用程序。<br>微服务是一种以业务功能为主的服务设计，通过将功能分散到各个离散的服务中以实现对解决方案的解耦，所以每一个服务都具有自主运行的业务功能。微服务只属于一个应用程序，它要求业务系统彻底的组件化和服务化。<br>服务化是一种粗粒度、松耦合的以服务为中心的架构，服务之间通过定义明确的协议和接口进行通信。</p>
<h2 id="好的架构应该具备的特征"><a href="#好的架构应该具备的特征" class="headerlink" title="好的架构应该具备的特征"></a>好的架构应该具备的特征</h2><p>基于资源的接口设计<br>开发团队结构要正确映射系统架构<br>要考虑业务架构和组织架构</p>
<p>参考文章:<br><a href="http://colobu.com/2015/04/08/software-architecture-patterns/" target="_blank" rel="external">软件架构模式</a><br><a href="https://www.zhihu.com/question/37808426" target="_blank" rel="external">SOA和微服务的区别</a><br><a href="http://dockone.io/article/394" target="_blank" rel="external">微服务架构的优势与不足</a><br><a href="https://www.ibm.com/developerworks/community/blogs/3302cc3b-074e-44da-90b1-5055f1dc0d9c/entry/%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84_%E4%B8%80_%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1?lang=en" target="_blank" rel="external">解析微服务架构(一)</a><br><a href="http://www.jianshu.com/p/546ef242b6a3" target="_blank" rel="external">基于微服务的软件架构模式</a><br><a href="http://www.hollischuang.com/archives/1628" target="_blank" rel="external">组件化、模块化、集中式、分布式、服务化、面向服务的架构、微服务架构</a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/10/28/Software-Architecture/" class="archive-article-date">
  	<time datetime="2016-10-28T06:46:47.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-10-28</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/technical/">technical</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-Continuous-Integration" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/25/Continuous-Integration/">持续集成(Continuous Integration)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在工作之前,曾经遇到过这么一个问题,和多个小伙伴一起开发,一个人负责了一大块的功能,最后在每个人完成各自的开发工作以后,集成成一个系统。<br>这真的是很痛苦的一件事情,没有任何的铺垫,一堆冲突,集成后也不知道系统是不是存在bug。<br>然而在真正工作以后,才发现了这些问题的正确打开方式。</p>
<h2 id="持续集成是什么"><a href="#持续集成是什么" class="headerlink" title="持续集成是什么"></a>持续集成是什么</h2><p>Martin Fowler对持续集成(Continuous Integration)的定义:</p>
<blockquote>
<p>Continuous Integration is a software development practice where members of a team integrate their work frequently, usually each person integrates at least daily - leading to multiple integrations per day. Each integration is verified by an automated build (including test) to detect integration errors as quickly as possible.Many teams find that this approach leads to significantly reduced integration problems and allows a team to develop cohesive software more rapidly.  </p>
</blockquote>
<p>持续集成是一种软件开发实践，即团队开发成员经常集成他们的工作，通常每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试)来验证，从而尽快地发现集成错误。许多团队发现这个过程可以大大减少集成的问题，让团队能够更快的开发内聚的软件。</p>
<p>Martin Fowler对持续集成的内容概述:</p>
<blockquote>
<p>Maintain a Single Source Repository.<br>  Automate the Build<br>  Make Your Build Self-Testing<br>  Everyone Commits To the Mainline Every Day<br>  Every Commit Should Build the Mainline on an Integration Machine<br>  Fix Broken Builds Immediately<br>  Keep the Build Fast<br>  Test in a Clone of the Production Environment<br>  Make it Easy for Anyone to Get the Latest Executable<br>  Everyone can see what’s happening<br>  Automate Deployment</p>
</blockquote>
<p>  1.统一的代码库。一个团队在开发过程中都需要一个代码库,每个人写的代码都更新到同一个代码库上。例如Github,Gitlab等,如此一来就需要版本管理工具例如git,svn等等。<br>  2.自动构建。手动构建的代价太大,使用工具来自动构建。<br>  3.自动测试。<br>  4.每个人每天都要向代码库主干提交代码。<br>  5.每次代码递交后都会在持续集成服务器上触发一次构建。<br>  6.保证快速构建。<br>  7.模拟生产环境的自动测试。<br>  8.每个人都可以很容易的获取最新可执行的应用程序。<br>  9.每个人都清楚正在发生的状况。<br>  10.自动化的部署。</p>
<h2 id="持续集成的好处"><a href="#持续集成的好处" class="headerlink" title="持续集成的好处"></a>持续集成的好处</h2><p>由上可知,持续集成的好处在于:<br>    (1)快速发现错误。每个coder完成了一小段代码就更新集成到主干,如此一来可以快速的发现错误,并且定位错误,改正错误。<br>    (2)使得代码不会大幅度的偏离主干。如果不经常集成代码,更新不快,最后集成的难度非常大。<br>    (3)在任何时间、任何地点生成可部署的软件。对于客户来说,这便于持续交付。<br>    (4)改善对进度的控制。每天都在集成，就可以看到当前各个功能的进度。<br>    (5)更加充分地测试系统中的各个单元。<br>    (6)与其它工具结合的持续代码质量改进。如使用CheckStyle, PMD, FindBugs, Fxcop等。<br>    (7)便于Code Review。在每个build里，我们都可以知道与前一个build之间有什么改动，然后针对这些改动，我们就可以实施Code Review了。<br>    (8)便于开发流程的管理。比如说，要把一个开发的build提交给测试组作测试，测完满意了，再提交到发布组去发布。</p>
<p> 持续集成的目的，就是让产品可以保持高质量的快速迭代。</p>
<h2 id="持续集成的工具"><a href="#持续集成的工具" class="headerlink" title="持续集成的工具"></a>持续集成的工具</h2><p>CI工具实现了每个开发人员提交代码的时候自动进行构建，包括代码审查、编译、测试、打包等操作。如此可以保证每次提交都是安全的。<br>CI工具还可以提供事件通知,生成报告等。例如当某一步构建失败了发送通知给指定的email、通过特定的设置发出声音等。<br>常见的工具有:<br><a href="https://jenkins.io/index.html" target="_blank" rel="external">Jenkins</a><br><a href="https://www.go.cd/" target="_blank" rel="external">Go</a><br><a href="http://buildbot.net/" target="_blank" rel="external">Buildbot</a></p>
<h2 id="持续集成的规则："><a href="#持续集成的规则：" class="headerlink" title="持续集成的规则："></a>持续集成的规则：</h2><p>  总结规则如下:<br>1）经常提交代码<br>2）不要提交无法构建的代码<br>3）构建失败时，立即修复<br>4）写自动化测试<br>5）必须通过所有测试和代码审查<br>6）执行私有构建<br>7）避免迁出无法构建的代码</p>
<p>遵循以上规则是为了提高CI持续集成成功率，及时修复build</p>
<p>参考文献:<br><a href="http://martinfowler.com/articles/continuousIntegration.html" target="_blank" rel="external">Martin Fowler的Continuous Integration</a><br><a href="http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html" target="_blank" rel="external">持续集成是什么？</a><br><a href="http://www.cnblogs.com/huang0925/p/3333484.html" target="_blank" rel="external">让你的CI跑起来</a><br><a href="http://holbrook.github.io/2014/03/04/ci_tools.html" target="_blank" rel="external">持续集成工具的作用</a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/10/25/Continuous-Integration/" class="archive-article-date">
  	<time datetime="2016-10-25T03:33:21.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-10-25</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CI/">CI</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/technical/">technical</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-markdown" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/09/markdown/">使用Markdown编辑器写博客</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本博客非原创,,转自CSDN官方编辑器提示,用来帮组小伙伴使用markdown写博客</p>
<p>正文如下:</p>
<p>本Markdown编辑器使用<a href="https://github.com/benweet/stackedit" target="_blank" rel="external">StackEdit</a>修改而来，用它写博客，将会带来全新的体验哦：</p>
<ul>
<li><strong>Markdown和扩展Markdown简洁的语法</strong></li>
<li><strong>代码块高亮</strong></li>
<li><strong>图片链接和图片上传</strong></li>
<li><strong><em>LaTex</em>数学公式</strong></li>
<li><strong>UML序列图和流程图</strong></li>
<li><strong>离线写博客</strong></li>
<li><strong>导入导出Markdown文件</strong></li>
<li><strong>丰富的快捷键</strong></li>
</ul>
<hr>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul>
<li>加粗    <code>Ctrl + B</code></li>
<li>斜体    <code>Ctrl + I</code></li>
<li>引用    <code>Ctrl + Q</code></li>
<li>插入链接    <code>Ctrl + L</code></li>
<li>插入代码    <code>Ctrl + K</code></li>
<li>插入图片    <code>Ctrl + G</code></li>
<li>提升标题    <code>Ctrl + H</code></li>
<li>有序列表    <code>Ctrl + O</code></li>
<li>无序列表    <code>Ctrl + U</code></li>
<li>横线    <code>Ctrl + R</code></li>
<li>撤销    <code>Ctrl + Z</code></li>
<li>重做    <code>Ctrl + Y</code></li>
</ul>
<h2 id="Markdown及扩展"><a href="#Markdown及扩展" class="headerlink" title="Markdown及扩展"></a>Markdown及扩展</h2><blockquote>
<p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。    —— <a href="https://zh.wikipedia.org/wiki/Markdown" target="_blank"> [ 维基百科 ]</a></p>
</blockquote>
<p>使用简单的符号标识不同的标题，将某些文字标记为<strong>粗体</strong>或者<em>斜体</em>，创建一个<a href="http://www.csdn.net" target="_blank" rel="external">链接</a>等，详细语法参考帮助？。</p>
<p>本编辑器支持 <strong>Markdown Extra</strong> , 　扩展了很多好用的功能。具体请参考<a href="https://github.com/jmcmanus/pagedown-extra" title="Pagedown Extra" target="_blank" rel="external">Github</a>.</p>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p><strong>Markdown　Extra</strong>　表格语法：</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>价格</th>
</tr>
</thead>
<tbody>
<tr>
<td>Computer</td>
<td>$1600</td>
</tr>
<tr>
<td>Phone</td>
<td>$12</td>
</tr>
<tr>
<td>Pipe</td>
<td>$1</td>
</tr>
</tbody>
</table>
<p>可以使用冒号来定义对齐方式：</p>
<table>
<thead>
<tr>
<th style="text-align:left">项目</th>
<th style="text-align:right">价格</th>
<th style="text-align:center">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Computer</td>
<td style="text-align:right">1600 元</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:left">Phone</td>
<td style="text-align:right">12 元</td>
<td style="text-align:center">12</td>
</tr>
<tr>
<td style="text-align:left">Pipe</td>
<td style="text-align:right">1 元</td>
<td style="text-align:center">234</td>
</tr>
</tbody>
</table>
<h3 id="定义列表"><a href="#定义列表" class="headerlink" title="定义列表"></a>定义列表</h3><p><strong>Markdown　Extra</strong>　定义列表语法：<br>项目１<br>项目２<br>:   定义 A<br>:   定义 B</p>
<p>项目３<br>:   定义 C</p>
<p>:   定义 D</p>
<pre><code>&gt; 定义D内容
</code></pre><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>代码块语法遵循标准markdown代码，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@requires_authorization</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">somefunc</span><span class="params">(param1=<span class="string">''</span>, param2=<span class="number">0</span>)</span>:</span></div><div class="line">    <span class="string">'''A docstring'''</span></div><div class="line">    <span class="keyword">if</span> param1 &gt; param2: <span class="comment"># interesting</span></div><div class="line">        <span class="keyword">print</span> <span class="string">'Greater'</span></div><div class="line">    <span class="keyword">return</span> (param2 - param1 + <span class="number">1</span>) <span class="keyword">or</span> <span class="keyword">None</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>message = <span class="string">'''interpreter</span></div><div class="line"><span class="meta">... </span>prompt'''</div></pre></td></tr></table></figure></p>
<h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><p>生成一个脚注[^footnote].<br>  [^footnote]: 这里是 <strong>脚注</strong> 的 <em>内容</em>.</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>用 <code>[TOC]</code>来生成目录：</p>
<p>[TOC]</p>
<h3 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h3><p>使用MathJax渲染<em>LaTex</em> 数学公式，详见<a href="http://math.stackexchange.com/" target="_blank" rel="external">math.stackexchange.com</a>.</p>
<ul>
<li>行内公式，数学公式为：$\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$。</li>
<li>块级公式：</li>
</ul>
<p>$$    x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$</p>
<p>更多LaTex语法请参考 <a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="external">这儿</a>.</p>
<h3 id="UML-图"><a href="#UML-图" class="headerlink" title="UML 图:"></a>UML 图:</h3><p>可以渲染序列图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">张三-&gt;李四: 嘿，小四儿, 写博客了没?</div><div class="line">Note right of 李四: 李四愣了一下，说：</div><div class="line">李四--&gt;张三: 忙得吐血，哪有时间写。</div></pre></td></tr></table></figure>
<p>或者流程图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">st=&gt;start: 开始</div><div class="line">e=&gt;end: 结束</div><div class="line">op=&gt;operation: 我的操作</div><div class="line">cond=&gt;condition: 确认？</div><div class="line"></div><div class="line">st-&gt;op-&gt;cond</div><div class="line">cond(yes)-&gt;e</div><div class="line">cond(no)-&gt;op</div></pre></td></tr></table></figure>
<ul>
<li>关于 <strong>序列图</strong> 语法，参考 <a href="http://bramp.github.io/js-sequence-diagrams/" target="_blank" rel="external">这儿</a>,</li>
<li>关于 <strong>流程图</strong> 语法，参考 <a href="http://adrai.github.io/flowchart.js/" target="_blank" rel="external">这儿</a>.</li>
</ul>
<h2 id="离线写博客"><a href="#离线写博客" class="headerlink" title="离线写博客"></a>离线写博客</h2><p>即使用户在没有网络的情况下，也可以通过本编辑器离线写博客（直接在曾经使用过的浏览器中输入<a href="http://write.blog.csdn.net/mdeditor" target="_blank" rel="external">write.blog.csdn.net/mdeditor</a>即可。<strong>Markdown编辑器</strong>使用浏览器离线存储将内容保存在本地。</p>
<p>用户写博客的过程中，内容实时保存在浏览器缓存中，在用户关闭浏览器或者其它异常情况下，内容不会丢失。用户再次打开浏览器时，会显示上次用户正在编辑的没有发表的内容。</p>
<p>博客发表后，本地缓存将被删除。　</p>
<p>用户可以选择 <i class="icon-disk"></i> 把正在写的博客保存到服务器草稿箱，即使换浏览器或者清除缓存，内容也不会丢失。</p>
<blockquote>
<p><strong>注意：</strong>虽然浏览器存储大部分时候都比较可靠，但为了您的数据安全，在联网后，<strong>请务必及时发表或者保存到服务器草稿箱</strong>。</p>
</blockquote>
<h2 id="浏览器兼容"><a href="#浏览器兼容" class="headerlink" title="浏览器兼容"></a>浏览器兼容</h2><ol>
<li>目前，本编辑器对Chrome浏览器支持最为完整。建议大家使用较新版本的Chrome。</li>
<li>IE９以下不支持</li>
<li>IE９，１０，１１存在以下问题<ol>
<li>不支持离线功能</li>
<li>IE9不支持文件导入导出</li>
<li>IE10不支持拖拽文件导入</li>
</ol>
</li>
</ol>
<hr>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/10/09/markdown/" class="archive-article-date">
  	<time datetime="2016-10-09T01:33:08.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-10-09</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/technical/">technical</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  


      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 Shengzhi Wang
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
  本站总访问量 <span id="busuanzi_value_site_pv"></span> 次, 访客数 <span id="busuanzi_value_site_uv"></span> 人次, 本文总阅读量 <span id="busuanzi_value_page_pv"></span> 次

  <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

</footer>

    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/"
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
      <li data-hook="tools-section-friends"><span class="text">友链</span><i class="icon-link"></i></li>
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<a href="/tags/Angular/" style="font-size: 15px;">Angular</a> <a href="/tags/CI/" style="font-size: 10px;">CI</a> <a href="/tags/Docker/" style="font-size: 17.5px;">Docker</a> <a href="/tags/Github/" style="font-size: 10px;">Github</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/ansible/" style="font-size: 10px;">ansible</a> <a href="/tags/essays/" style="font-size: 12.5px;">essays</a> <a href="/tags/html5/" style="font-size: 12.5px;">html5</a> <a href="/tags/technical/" style="font-size: 20px;">technical</a>
    			</div>
    	</section>
    

    
    	<section class="tools-section tools-section-friends">
  		
  			<div class="friends-wrap" id="js-friends">
  			
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/wszhi">我的Github</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://blog.csdn.net/u012138931">我的CSDN</a>
  	        
  	        </div>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">靡不有初，&lt;br&gt;&lt;br&gt;鲜克有终。&lt;br&gt;&lt;br&gt;不断努力,一步一步往前走,做最好的自己</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>
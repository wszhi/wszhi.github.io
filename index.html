<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Shengzhi Wang</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="靡不有初,鲜克有终">
<meta property="og:type" content="website">
<meta property="og:title" content="Shengzhi Wang">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Shengzhi Wang">
<meta property="og:description" content="靡不有初,鲜克有终">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Shengzhi Wang">
<meta name="twitter:description" content="靡不有初,鲜克有终">
  
    <link rel="alternative" href="/atom.xml" title="Shengzhi Wang" type="application/atom+xml">
  
  
    <link rel="icon" href="//favicon.png">
  
  <script src="/style.js"></script>
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="http://store.aimon.cn/Product/photo/348/2012101905747.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Shengzhi Wang</a></h1>
		</hgroup>

		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/tags/technical/">技术</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">友链</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="3" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/wszhi" title="github">github</a>
		        
					<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
		        
					<a class="rss" target="_blank" href="#" title="rss">rss</a>
		        
					<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">Shengzhi Wang</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="http://store.aimon.cn/Product/photo/348/2012101905747.jpg" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">Shengzhi Wang</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/tags/technical/">技术</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/wszhi" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        
  
    <article id="post-Docker-learn3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/09/Docker-learn3/">Docker 学习笔记(三)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>持续更新中。。。</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/11/09/Docker-learn3/" class="archive-article-date">
  	<time datetime="2016-11-09T07:19:05.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-11-09</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Docker/">Docker</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/technical/">technical</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-Docker-Learn2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/07/Docker-Learn2/">Docker 学习笔记(二)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Docker 目的是在减少软件开发周期中最繁琐、最耗时的环境准备环节。<br>Docker满足了免费的、轻量级、可移植、虚拟化、资源隔离、数据统一、语言无关、封装后的镜像可以随处部署和迁移这些要求。</p>
<h2 id="Docker优缺点"><a href="#Docker优缺点" class="headerlink" title="Docker优缺点"></a>Docker优缺点</h2><h4 id="Docker优点"><a href="#Docker优点" class="headerlink" title="Docker优点"></a>Docker优点</h4><p>1)Docker的资源利用率比传统虚拟机要高<br>2)Docker支持跨节点部署<br>3)版本可控,组件可复用<br>4)共享镜像<br>5)轻量,易维护</p>
<h4 id="Docker缺点"><a href="#Docker缺点" class="headerlink" title="Docker缺点"></a>Docker缺点</h4><p>1)宿主资源没有完成做到隔离<br>2)Golang语言尚未成熟<br>3)Docker虽已经开源,但在在未来可能收费</p>
<h2 id="Boot2Docker"><a href="#Boot2Docker" class="headerlink" title="Boot2Docker"></a>Boot2Docker</h2><p>Boot2Docker 是一个包含了 VirtualBox 虚拟软件、Docker 程序和Boot2Docker Management Tool的一个集合软件。Boot2Docker Management Tool是一个运行在Mac系统上的轻量级Linux虚拟机。<br>这个轻量级虚拟机完全运行在内存中,启动很快,体积很小。<br>通过Boot2Docker安装的Docker相当于运行在一个 VirtualBox 虚拟机中,而客户端运行在Mac OS 上。<br>(Mac直接安装Docker,不通过Boot2Docker安装感觉起来没什么区别啊?)</p>
<h2 id="Docker中的某些命令"><a href="#Docker中的某些命令" class="headerlink" title="Docker中的某些命令"></a>Docker中的某些命令</h2><h4 id="logs-获取容器内部应用输出的日志-只能获取到重定向到STDOUT和STDERR的日志"><a href="#logs-获取容器内部应用输出的日志-只能获取到重定向到STDOUT和STDERR的日志" class="headerlink" title="logs 获取容器内部应用输出的日志,只能获取到重定向到STDOUT和STDERR的日志"></a>logs 获取容器内部应用输出的日志,只能获取到重定向到STDOUT和STDERR的日志</h4><h4 id="attach-挂载到正在运行的容器中-并且可以在容器中执行任何命令"><a href="#attach-挂载到正在运行的容器中-并且可以在容器中执行任何命令" class="headerlink" title="attach 挂载到正在运行的容器中,并且可以在容器中执行任何命令"></a>attach 挂载到正在运行的容器中,并且可以在容器中执行任何命令</h4><p>可以通过ID和name挂载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">➜  ~ docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</div><div class="line">6caf2b2b8d00        b1873e247b48        &quot;/bin/bash&quot;         32 minutes ago      Up 32 minutes                           reverent_thompson</div><div class="line">➜  ~ docker attach 6caf2b2b8d00</div><div class="line">root@6caf2b2b8d00:/#</div></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜  ~ docker attach reverent_thompson</div><div class="line">root@6caf2b2b8d00:/#</div></pre></td></tr></table></figure></p>
<p>通过Ctrl+P+Q来退出容器,容器还在运行中。<br>使用exit退出容器,容器同步被关闭。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">root@6caf2b2b8d00:/# exit 10</div><div class="line">➜  ~ docker ps -a |grep reverent_thompson</div><div class="line">6caf2b2b8d00        b1873e247b48         &quot;/bin/bash&quot;              52 minutes ago      Exited (10) 45 seconds ago                       reverent_thompson</div></pre></td></tr></table></figure></p>
<p>Exited (10) 容器的退出响应码变成了10,即可以通过exit命令来指定容器退出码。</p>
<h4 id="build-创建image"><a href="#build-创建image" class="headerlink" title="build 创建image"></a>build 创建image</h4><p>读取配置文件构建image(文件名默认Dockerfile,也可以自定义):<br>1)”-“表示将从STDIN读入数据,即将Dockerfile中的数据通过STDIN传入build中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Docker build - &lt; Dockerfile</div></pre></td></tr></table></figure></p>
<p>2)PATH参数表示Dockerfile全路径,即将Dockerfile放置到$(HOME)/Users目录下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Docker build $(HOME)/Users/Dockerfile</div><div class="line">Docker build $(HOME)/Users/otherfile    名字可变</div></pre></td></tr></table></figure></p>
<p>3)使用URL参数,URL必须指向一个git地址。Docker会把指定的git仓库克隆到本地,然后把仓库中的Dockerfile内容传给Docker Daemon。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Docker build https://github.com/wszhi/Docker-image.git#container:Docker</div></pre></td></tr></table></figure></p>
<p>以上命令通知Docker Daemon加载<a href="https://github.com/wszhi/Docker-image.git" target="_blank" rel="external">https://github.com/wszhi/Docker-image.git</a> 仓库,切换到container分支,在Docker目录下的Dockerfile文件来构建image。<br>注意: “:”后面的是Dockerfile文件的路径,此方式不支持自定义命名。若为master分支#后为空<br>若当前目录有Dockerfile文件可以省略路径使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Docker build --rm=false .</div></pre></td></tr></table></figure></p>
<p>–rm=false表示不删除临时镜像,当经常构建且变化不大的时候建议使用。</p>
<h4 id="commit-以某个容器为基础保存成一个新的image"><a href="#commit-以某个容器为基础保存成一个新的image" class="headerlink" title="commit 以某个容器为基础保存成一个新的image"></a>commit 以某个容器为基础保存成一个新的image</h4><p>-a, –author=””这个参数的目标是保存新的作者。<br>-c, –change=[]这个参数保存的是修改image里面的配置参数。<br>目前支持的可以修改的配置参数有CMD|ENTRYPOINT|ENV|EXPOSE|LABEL|ONBUILD|USER|VOLUME|WORKDIR。其余的参数继承于上一个image<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜  ~ docker commit --change &quot;ENV DEBUG true&quot; 3af7938d2d31 svendowideit/testimage:version1</div><div class="line">sha256:c24a8c4cf76d9485e69fa4d975a6b8ccc3070dbf368a118672ab6a76a4249605</div></pre></td></tr></table></figure></p>
<p>3af7938d2d31是一个正在运行的容器,svendowideit/testimage是repository的名字,version1是tag的内容<br>查看结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜  ~ Docker inspect -f &quot;&#123;&#123; .Config.Env&#125;&#125;&quot; c24a8c4cf76d</div><div class="line">[DEBUG=true no_proxy=local PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin]</div></pre></td></tr></table></figure></p>
<p>-m, –message=””这个参数是提交一个comment备注信息,说明image的用途,修改的内容等信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">➜  ~  docker commit -m &quot;test message&quot; 3af7938d2d31 svendowideit/testimage:version2</div><div class="line">sha256:0d4f24b6a8d7d7239b9cfa163845c09866f30de9cc7ac23d48510e3ac095f6a4</div><div class="line">➜  ~ Docker inspect 0d4f24b6a8d7</div><div class="line">[</div><div class="line">    &#123;</div><div class="line">        &quot;Id&quot;: &quot;sha256:0d4f24b6a8d7d7239b9cfa163845c09866f30de9cc7ac23d48510e3ac095f6a4&quot;,</div><div class="line">        &quot;RepoTags&quot;: [</div><div class="line">            &quot;svendowideit/testimage:version2&quot;</div><div class="line">        ],</div><div class="line">        &quot;RepoDigests&quot;: [],</div><div class="line">        &quot;Parent&quot;: &quot;sha256:78a0e8d9b39cdcbb93d433ec5de61ba6c6d10369eccdf45b7e60318b47356d9a&quot;,</div><div class="line">        &quot;Comment&quot;: &quot;test message&quot;,</div><div class="line">        .........</div><div class="line">     &#125;</div><div class="line">]</div></pre></td></tr></table></figure></p>
<p>-p, –pause=true 默认情况下执行commit时,容器中所有进程处于暂停状态,如果此时容器对外提供服务,那其他容器会受到影响。<br>-pause=false使用这个参数使得在执行commit时保持容器内进程继续工作。但是commit效率会下降。</p>
<h4 id="create-创建容器"><a href="#create-创建容器" class="headerlink" title="create 创建容器"></a>create 创建容器</h4><p>create命令是以image为模板创建的一个容器,并且在容器文件的最上面一层添加一个读写层,容器里面的数据变化会被保存在读写层。<br>create成功后需要通过start来启动容器。<br>参数:<br>-i 将Host的Stdin和容器的Stdin相连接<br>-t 创建一个pty终端<br>(-it 前两者结合使用相当于在host环境中启动一个链接容器的pty伪终端,在host的pty中输入的数据就会传到容器之中。)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">➜  ~ docker create -it addwszfile bash</div><div class="line">7019c6b575fe673954f2019a99fb6679b7a2f4a604d324290ff5111c42feae2b</div><div class="line">➜  ~ docker create -it -v /dockerforme/sinatra/share_folder/:/tmp --name data1 addwszfile</div><div class="line">7cfc3205a8df843d1b7219a31f51976b5df638cb20a03c57134ec690da990875</div><div class="line">➜  ~ docker create -P --name data2 addwszfile</div></pre></td></tr></table></figure></p>
<p>addwszfile是image名称。</p>
<p>-p 映射网络端口,当应用需要访问其他应用或被访问,需要开放一个端口<br>-P 容器中所有需要暴露的端口都会映射到主机随机的一个端口(端口范围49153~65535)<br>-v 挂载参数,把主机的一个文件或者一个目录挂载到容器中</p>
<h4 id="diff-比较容器文件文件层数据差异的命令"><a href="#diff-比较容器文件文件层数据差异的命令" class="headerlink" title="diff 比较容器文件文件层数据差异的命令"></a>diff 比较容器文件文件层数据差异的命令</h4><p>首先启动一个容器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker run -t -i ubuntu:12.04 /bin/bash</div></pre></td></tr></table></figure></p>
<p>在容器中做某些操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">root@543f21cb4a4e:/# touch /tmp/wsz.txt</div><div class="line">root@543f21cb4a4e:/# echo &quot;This is wsz add test&quot; &gt; /tmp/wsz.txt</div><div class="line">root@543f21cb4a4e:/# touch /tmp/wsz2.txt</div><div class="line">root@543f21cb4a4e:/# rm /tmp/wsz2.txt</div><div class="line">root@543f21cb4a4e:/# touch /tmp/wsz3.txt</div><div class="line">root@543f21cb4a4e:/# echo &quot;This is a change test&quot; &gt; /tmp/wsz3.txt</div><div class="line">root@543f21cb4a4e:/# echo &quot;I add a new line&quot; &gt;&gt; /tmp/wsz3.txt</div></pre></td></tr></table></figure></p>
<p>新开一个命令行窗口,查看diff<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">➜  ~ docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</div><div class="line">543f21cb4a4e        ubuntu:12.04        &quot;/bin/bash&quot;         4 minutes ago       Up 4 minutes                            trusting_bell</div><div class="line">➜  ~ docker diff 543f21cb4a4e</div><div class="line">C /tmp</div><div class="line">A /tmp/wsz.txt</div><div class="line">A /tmp/wsz3.txt</div></pre></td></tr></table></figure></p>
<p>结果中的A表示add;C表示Change;D表示Delete<br>可以看见之中我们是创建一个wsz2.txt的文件然后又删除了,但是在diff中并没有反应出来,这是因为我们操作产生的数据保存在最上面的读写层里,diff比较的是最上层和其他层的差异,其中wsz2的文件不存在于其他层所以不显示。<br>若想时时刻刻保存状态,可以save读写层,再进行删除。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">➜  ~ docker commit 543f21cb4a4e addwszfile</div><div class="line">sha256:b1873e247b48d2ffb12725552691db3c8a2d1f097efdfbb04aeddb9cf13d8c9c</div><div class="line">➜  ~ docker run -it b1873e247b48d2ffb12725552691db3c8a2d1f097efdfbb04aeddb9cf13d8c9c</div><div class="line">root@6caf2b2b8d00:/# rm /tmp/wsz.txt</div></pre></td></tr></table></figure></p>
<p>新开一个命令行窗口可以看到删除的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">➜  ~ docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</div><div class="line">6caf2b2b8d00        b1873e247b48        &quot;/bin/bash&quot;         40 seconds ago      Up 39 seconds                           reverent_thompson</div><div class="line">➜  ~ docker diff 6caf2b2b8d00</div><div class="line">C /tmp</div><div class="line">D /tmp/wsz.txt</div></pre></td></tr></table></figure></p>
<h4 id="events-获取容器所报告的事件"><a href="#events-获取容器所报告的事件" class="headerlink" title="events 获取容器所报告的事件"></a>events 获取容器所报告的事件</h4><p>Docker容器再运行过程中会向Docker Daemon报告如下事件:<br>create、destroy、die、export、kill、oom、pause、start、stop、unpause<br>Image镜像会向Docker Daemon报告untag、delete事件<br>筛选的几种方式:<br>–since 指从某一个时间点开始Docker Daemon接收的所有事件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜  ~ docker events --since &apos;2016-09-01&apos;</div></pre></td></tr></table></figure></p>
<p>–until 需要和 –since结合使用,指的是从某一个时间点开始到某一个时间点结束。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜  ~ docker events --since &apos;2016-09-01&apos; --until &apos;2016-11-08T15:00:00&apos;</div></pre></td></tr></table></figure></p>
<p>–filter 接收的是key=value的键值对。目前有效的key是container、event、image。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">➜  ~ docker events --filter &apos;event=stop&apos;</div><div class="line">➜  ~ docker events --filter &apos;image=ubuntu:14.04&apos;</div><div class="line">➜  ~ docker events --filter &apos;container=543f21cb4a4e&apos;</div></pre></td></tr></table></figure></p>
<h4 id="exec-在容器中运行其他命令"><a href="#exec-在容器中运行其他命令" class="headerlink" title="exec 在容器中运行其他命令"></a>exec 在容器中运行其他命令</h4><p>执行ps删选进程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜  ~ docker exec 6caf2b2b8d00 ps -s|grep bash</div></pre></td></tr></table></figure></p>
<p>创建一个新文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜  ~ docker exec 6caf2b2b8d00 touch /tmp/1.txt</div></pre></td></tr></table></figure></p>
<p>修改文件,前提需要申请一个pty和绑定一个stdin用来保存编辑的文件,因为没有pty容器无法收到控制字符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜  ~ docker exec -it 6caf2b2b8d00 vi /tmp/1.txt</div></pre></td></tr></table></figure></p>
<h4 id="history-追踪image的历史记录"><a href="#history-追踪image的历史记录" class="headerlink" title="history 追踪image的历史记录"></a>history 追踪image的历史记录</h4><p>diff 查看的是容器中文件系统的变更历史。History查看的是image的变更历史。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜  ~ docker history ouruser/sinatra:v3</div></pre></td></tr></table></figure></p>
<p>-H,–human 表示是否输出方便用户识别的格式。<br>–no-trunc=false 默认false,表示将输出按照一定的格式进行截断。<br>–quiet 若是设置为true,只返回image构建过程中所有的临时文件层的image ID,为false时返回所有信息。</p>
<h4 id="info-显示Docker摘要信息"><a href="#info-显示Docker摘要信息" class="headerlink" title="info 显示Docker摘要信息"></a>info 显示Docker摘要信息</h4><p>info 指令显示Docker摘要信息,用来确认Docker信息。包含Docker内核版本号、Docker所设定的CPU、内存参数等环境底层信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜  ~ docker info</div></pre></td></tr></table></figure></p>
<h4 id="inspect-返回指定目标的底层信息"><a href="#inspect-返回指定目标的底层信息" class="headerlink" title="inspect 返回指定目标的底层信息"></a>inspect 返回指定目标的底层信息</h4><p>inspect可以返回image和container的底层信息。包括某个容器的IP地址,MAC地址,端口信息等等。<br>返回的几类信息:<br>1.基本信息类:名称,创建时间,当前状态(运行、停止、暂停)等<br>2.运行参数类:网络信息、环境变量、主机名称等<br>3.底层数据类:CPU设置、内存设置、虚拟化设置等<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker inspect -f &#123;&#123;要查看的参数名&#125;&#125; ID号</div><div class="line">docker inspect -f &apos;&#123;&#123;json .Config&#125;&#125;&apos; ID号</div><div class="line">docker inspect -f &apos;&#123;&#123;(index (index .Config &quot;Env&quot;) 0)&#125;&#125;&apos; ID号              取出Config中Env第一个元素命令</div></pre></td></tr></table></figure></p>
<p>json是指把数据格式化成json字符串<br>index取第几个</p>
<h4 id="kill-强制停止容器"><a href="#kill-强制停止容器" class="headerlink" title="kill 强制停止容器"></a>kill 强制停止容器</h4><p>一般使用stop关掉容器。出现异常使用kill<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker kill 容器名</div></pre></td></tr></table></figure></p>
<h4 id="ps-查看当前容器的运行状态"><a href="#ps-查看当前容器的运行状态" class="headerlink" title="ps 查看当前容器的运行状态"></a>ps 查看当前容器的运行状态</h4><h4 id="rename-对容器重命名"><a href="#rename-对容器重命名" class="headerlink" title="rename 对容器重命名"></a>rename 对容器重命名</h4><p>docker rename 旧名字 新名字</p>
<h4 id="tag-对镜像重命名"><a href="#tag-对镜像重命名" class="headerlink" title="tag 对镜像重命名"></a>tag 对镜像重命名</h4><p>……还有很多命令看文档</p>
<p>参考书籍<br>《Docker 全攻略》张涛著<br><a href="https://docs.docker.com/" target="_blank" rel="external">《Docker 官方文档》</a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/11/07/Docker-Learn2/" class="archive-article-date">
  	<time datetime="2016-11-07T06:53:22.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-11-07</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Docker/">Docker</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/technical/">technical</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-List-Task" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/02/List-Task/">任务分解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>对于一个程序媛来说,如何提高自己的开发效率,这一直都是我追寻的方法。直到最近才get到一个可以有所帮助的技能。</p>
<h2 id="任务分解-列Task"><a href="#任务分解-列Task" class="headerlink" title="任务分解,列Task"></a>任务分解,列Task</h2><p>当我们拿到一个任务卡片时,经常干的一件事,就是明确卡片中的要求和明细,然后就直接开始码代码了。因为写的代码是可见的,运行成功会有极大成就感,然而其实这并不是一个好的方式。</p>
<p>在我们写代码之前应该根据卡片内容,从开发的角度把一个大卡分解成各个小任务,然后针对每个小任务进行开发才是可取的。其实这种方法得到的成就感并不亚于前者。</p>
<h4 id="Task-是什么-如何列"><a href="#Task-是什么-如何列" class="headerlink" title="Task 是什么,如何列"></a>Task 是什么,如何列</h4><p>很多人会和我一样困惑,要列Task,但是什么是Task呢?一般来说,一个function(函数),一个Process或者一个Code Block(代码块)都可以是一个Task。<br>每一个Task都有相应的输入和输出。输入的可以是函数的参数,全局变量,局部变量(对于代码块来说)。输出可以是返回值,变量等。</p>
<p>每个Task的输入都是可穷尽的,在列Task的时候要列出所有用到的Task。<br>列Task的时候的命名要精确,每一个名字在不同的地方有不同的意思。</p>
<p>列Task,一般会画一个包含Data和Process的图。类似一个有架构的数据流向图。Data(数据)一般有数组、队列、栈、树、对象、类、有循环的对象等,Process(过程)一般有顺序的、选择的(if/switch)、循环(for/while)等。</p>
<p>参考<br><a href="https://www.zybuluo.com/jtong/note/504192" target="_blank" rel="external">编程的精进之法</a></p>
<h2 id="PDCA-戴明环"><a href="#PDCA-戴明环" class="headerlink" title="PDCA 戴明环"></a>PDCA 戴明环</h2><p>PDCA指的是Plan-Do-Check-Action,而列Task属于Plan的内容。</p>
<p>如何定义Done?<br>1.code Done<br>2.test pass<br>3.Integration env<br>4.showcase<br>5.production env<br>6.ux(用户使用)</p>
<p>单个任务的开发流程:0)Spike即调研;1)写测试;2)写实现;3)测试通过</p>
<h2 id="例子一-打印学生成绩单"><a href="#例子一-打印学生成绩单" class="headerlink" title="例子一,打印学生成绩单"></a>例子一,打印学生成绩单</h2><h4 id="背景"><a href="#背景" class="headerlink" title="背景:"></a>背景:</h4><p><a href="https://www.zybuluo.com/jtong/note/471501" target="_blank" rel="external">https://www.zybuluo.com/jtong/note/471501</a>  中的课后作业<br>打印所有人的成绩单,包括平均分和总分。<br>打印全班级的总分平均分和中位数。</p>
<h4 id="列Task"><a href="#列Task" class="headerlink" title="列Task"></a>列Task</h4><h5 id="1-转换ViewModel"><a href="#1-转换ViewModel" class="headerlink" title="1) 转换ViewModel"></a>1) 转换ViewModel</h5><p>输入:</p>
<pre><code>studentScoresArray:[[String]]
</code></pre><p>输出:</p>
<pre><code>studentScoresSheet:[{
    name:String,
    chinese:double,
    english:double,
    math:double,
    programming:double
    },
    {
    ...
    }]
</code></pre><h5 id="2-得到学生成绩"><a href="#2-得到学生成绩" class="headerlink" title="2) 得到学生成绩"></a>2) 得到学生成绩</h5><p>输入:</p>
<pre><code>studentScoresSheet
</code></pre><p>输出:</p>
<pre><code>studentScoresSheetWithSummary:[{
    name:String,
    chinese:double,
    english:double,
    math:double,
    programming:double,
    average:double,
    total:double
    },
    {
     ...
    }]
</code></pre><h5 id="3-计算总计"><a href="#3-计算总计" class="headerlink" title="3) 计算总计"></a>3) 计算总计</h5><p>输入:</p>
<pre><code>studentScoresSheetWithSummary
</code></pre><p>输出:</p>
<pre><code>summary:{
    totalAverage:double,
    totalMidden:double
    }
</code></pre><h5 id="4-打印成绩单"><a href="#4-打印成绩单" class="headerlink" title="4) 打印成绩单"></a>4) 打印成绩单</h5><p>输入:</p>
<pre><code>studentScoresSheetWithSummary
summary
</code></pre><p>输出:</p>
<pre><code>Result:String
</code></pre><p><a href="https://github.com/wszhi/TaskConsoleStudentScoreInfo" target="_blank" rel="external">Github代码</a></p>
<h2 id="例子二-猜数字游戏"><a href="#例子二-猜数字游戏" class="headerlink" title="例子二,猜数字游戏"></a>例子二,猜数字游戏</h2><p><a href="https://github.com/raypeng/guess-number-raypeng/blob/master/README.md" target="_blank" rel="external">具体游戏内容</a><br>这个游戏有几个需要注意点:<br>1)Compare(两个数字对比的前提假设:符合要求的、合法的值)<br>2)生成随机数(生成的数是数字、四位、每位都不一样)<br>3)游戏流程(进入游戏–第一次成功/中间成功/最后一次成功/游戏失败)</p>
<p>PS:不能放过任何一个逻辑冲突;等加类划分可以使用正交分解法;还要考虑系统状态怎么保持<br>正交分解法:</p>
<pre><code> \ 位   |         |         | 
  \ 置  |         |         |
数 \    | 全都一样 | 全不一样 | 部分一样
字  \   |         |         |
--------------------------------------
全都一样 | 4A0B    | 0A4B    | 2A4B
全不一样 | 不可能   | 0A0B    | 不可能
部分一样 | 不可能   | 0A2B    | 2A2B
</code></pre><p>分解后的图如下:<br>1)应用启动<br><img src="http://img.blog.csdn.net/20161107144603037" alt=""></p>
<p>2)界面1(按1启动游戏)<br><img src="http://img.blog.csdn.net/20161107144618709" alt=""></p>
<p><img src="http://img.blog.csdn.net/20161107144638756" alt=""></p>
<p>main是解决输入输出的。<br>Router通过输入输出解析找到具体的Command。<br>Command处理各种具体的用户输入,对Core层返回的结果翻译成友好的输出。<br>Core层函数生成计算结果。</p>
<p>3)退出(按2退出游戏)<br><img src="http://img.blog.csdn.net/20161107144657923" alt=""></p>
<h2 id="例子三-邮编和条码的转化"><a href="#例子三-邮编和条码的转化" class="headerlink" title="例子三,邮编和条码的转化"></a>例子三,邮编和条码的转化</h2><h2 id="例子四-一对多web基础应用"><a href="#例子四-一对多web基础应用" class="headerlink" title="例子四,一对多web基础应用"></a>例子四,一对多web基础应用</h2><h2 id="例子五-多对多web基础应用"><a href="#例子五-多对多web基础应用" class="headerlink" title="例子五,多对多web基础应用"></a>例子五,多对多web基础应用</h2>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/11/02/List-Task/" class="archive-article-date">
  	<time datetime="2016-11-02T07:26:15.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-11-02</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/technical/">technical</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-ansible" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/31/ansible/">ansible</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>因为项目需要,所以提前学习了一下ansible,ansible是一个配置管理工具。</p>
<h2 id="ansible-安装"><a href="#ansible-安装" class="headerlink" title="ansible 安装"></a>ansible 安装</h2><p>Mac OS X 上安装Ansible,如果已经有Homebrew包管理工具可以直接运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install ansible</div></pre></td></tr></table></figure></p>
<p>Python包管理工具pip安装,root 安装方式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo pip install ansible</div></pre></td></tr></table></figure></p>
<p>非root安装方式,可以安装到一个Python virtualenv中,或者使用pipsi工具,自动安装到Python virtualenv中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">wget https://raw.githubusercontent.com/mitsuhiko/pipsi/master/get-pipsi.py</div><div class="line">python get-pipsi.py</div><div class="line">pipsi install ansible</div></pre></td></tr></table></figure></p>
<p>再将~/.local/bin添加到Path环境变量中。</p>
<p>使用pip安装docker-py和boto<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd ~/.local/venvs/ansible</div><div class="line">source bin/actiivate</div><div class="line">pip install docker-py boto</div></pre></td></tr></table></figure></p>
<p>ps: 安装wget<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">cd Downloads</div><div class="line">curl -O http://ftp.gnu.org/gnu/wget/wget-1.14.tar.gz</div><div class="line">tar xvzf wget-1.14.tar.gz</div><div class="line">cd wget-1.14</div><div class="line">./configure --with-ssl=openssl</div><div class="line">make</div><div class="line">sudo make install</div></pre></td></tr></table></figure></p>
<p><a href="https://coolestguidesontheplanet.com/install-and-configure-wget-on-os-x/" target="_blank" rel="external">install wget in Mac OS X</a></p>
<p>参考<a href="https://valdhaus.co/writings/ansible-mac-osx/" target="_blank" rel="external">install ansible on Mac</a><br><a href="http://docs.ansible.com/ansible/intro_installation.html" target="_blank" rel="external">ansible官方安装文档</a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/10/31/ansible/" class="archive-article-date">
  	<time datetime="2016-10-31T06:43:38.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-10-31</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ansible/">ansible</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/technical/">technical</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-Software-Architecture" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/28/Software-Architecture/">架构设计</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近在接受一个培训,第一次接触了架构设计的知识,有些名词晦涩难懂,导致在这一块的学习还是有所欠缺。<br>尽管如此,在培训中和培训后的努力学习后,做了点整理,理解的可能有所偏差,欢迎拍砖。</p>
<p>架构设计对于一个项目来说十分重要。</p>
<h2 id="一份完整的架构设计应该包括哪些内容"><a href="#一份完整的架构设计应该包括哪些内容" class="headerlink" title="一份完整的架构设计应该包括哪些内容"></a>一份完整的架构设计应该包括哪些内容</h2><p>1）建模，提炼资源<br>2）系统结构（BFF，业务流程）<br>3）开发团队结构<br>4）可用性与性能架构<br>5）安全性架构<br>6）质量架构<br>7）部署架构<br>8）运维架构<br>9）技术选型</p>
<h2 id="面向行为的接口设计与面向资源的接口设计-ROA"><a href="#面向行为的接口设计与面向资源的接口设计-ROA" class="headerlink" title="面向行为的接口设计与面向资源的接口设计(ROA)"></a>面向行为的接口设计与面向资源的接口设计(ROA)</h2><p>面向行为的接口设计是建立在动词（行为）的基础之上的，系统要枚举所有的业务行为，如果行为发生改变，接口也随之改变。<br>面向资源的接口设计便于实施、设计灵活、是轻量级的对象访问方式。<br>面向资源的接口设计关注的是名词（资源），解决了在业务需求发生变化时要对代码做很大的改变的问题。</p>
<h2 id="SOA-面向服务的架构设计"><a href="#SOA-面向服务的架构设计" class="headerlink" title="SOA 面向服务的架构设计"></a>SOA 面向服务的架构设计</h2><p>将紧耦合的系统,划分为面向业务的,粗粒度,松耦合,无状态的服务。<br>目的是提高软件的重用性，减少开发和维护的成本，最终增加敏捷度。</p>
<h2 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h2><p>微服务架构其中的一个重点是业务系统需要彻底的组件化和服务化,原来的业务可以拆分成独立的系统应用进行开发,这些相互独立的系统应用通过服务完成交互和集成。<br>它的目的是有效的拆分应用,实现敏捷开发和部署,为构建应用提供更轻量级、更高效的开发。</p>
<p>微服务不再强调传统SOA架构里面比较重的<strong>ESB</strong>企业服务总线，同时SOA的思想进入到单个业务系统内部实现真正的组件化。</p>
<h4 id="微服务足够构成一个独立的小应用-从DB到UI"><a href="#微服务足够构成一个独立的小应用-从DB到UI" class="headerlink" title="微服务足够构成一个独立的小应用(从DB到UI)"></a>微服务足够构成一个独立的小应用(从DB到UI)</h4><p>微服务的基本思想在于考虑围绕着业务领域组件来创建应用,这些应用可以独立的进行开发管理和加速。在分散的组件中使用微服务云架构和平台使部署管理和服务功能交付变得更加简单。</p>
<p>(<strong>Devops</strong>:开发测试和部署运维一体化。)</p>
<p>把单体应用拆分成多个小应用后,整体架构可以松耦合和可扩展,但是当拆分的组件越多,这些组件之间本省的集成和部署运维就越复杂。<br>任何一个组件,当依赖的外部应用组件越多的时候,整个集成,部署和连调测试的过程就越复杂,所以自动化这个过程可以减少工作量和出错概率。</p>
<p>微服务架构首先要做好单个组件本身的持续集成,其次在这个基础上增加了多个组件的打包部署和组件间的集成。包括环境变量的配置,自动打包部署,自动化的测试等。</p>
<p>不像传统多个服务共享一个数据库,微服务架构每个服务都有自己的数据库。</p>
<h4 id="一般运行在云虚拟机或者更轻的Docker上"><a href="#一般运行在云虚拟机或者更轻的Docker上" class="headerlink" title="一般运行在云虚拟机或者更轻的Docker上"></a>一般运行在云虚拟机或者更轻的Docker上</h4><p>微服务架构强调了单个组件本身可以在独立的进程里面运行,各个组件之间在部署的时候就能够做到进程级别的隔离性。<br>为了保持进程的隔离性,使用虚拟机,但是几十个进程都完全用独立的虚拟机就不现实,解决方案为利用Docker容器,每个Docker是独立的容器,完全做到了进程季节的隔离,资源占用率最小,满足了微服务架构的开发测试和自动化部署。</p>
<h4 id="微服务应用之间只能通过Service-API进行交互"><a href="#微服务应用之间只能通过Service-API进行交互" class="headerlink" title="微服务应用之间只能通过Service API进行交互"></a>微服务应用之间只能通过Service API进行交互</h4><p>单个服务的实现和发布仍然在组件内部完成,但是需要一个统一的SOA服务管理平台来显示服务本身的调用情况,服务本身的安全,日志和流量控制。<br>微服务强调采用HTTP Rest API的方式。<br>即微服务尽量通过HTTP API的方式暴露出去,因此这种服务管理平台需要基本的服务注册,服务代理,服务发布,服务简单的路由,安全访问和授权,服务调用消息和日志记录功能。</p>
<h3 id="微服务架构的优势"><a href="#微服务架构的优势" class="headerlink" title="微服务架构的优势"></a>微服务架构的优势</h3><p>1.通过分解巨大单体式应用为多个服务方法解决了复杂性问题。在功能不变的情况下,应用被分解为多个可管理的分支或服务。单个服务很容易开发、理解和维护。<br>2.每个服务都可以有专门的开发团队并行开发。<br>3.每个服务独立部署,不需要协调其他服务部署对本服务的影响,加快了部署速度,使得持续化部署成为可能。<br>4.每个服务可独立扩展。<br>5.每个服务足够内聚，足够小，代码容易理解、开发效率提高。<br>7.提高容错性，一个服务的内存泄露并不会让整个系统瘫痪。<br>8.可以使用多个技术栈,系统不会被技术栈长期限制。</p>
<h3 id="微服务架构的不足"><a href="#微服务架构的不足" class="headerlink" title="微服务架构的不足"></a>微服务架构的不足</h3><p>1.一个应用系统里面的模块没有办法做到彻底解耦,无法实现组件单独部署,相互之间有大量内部不可见依赖而导致了模块间的无法拆分。<br>2.微服务应用式分布式系统,会带来固有的复杂性。<br>3.分区的数据库架构带来的挑战,因为需要更新不同服务所使用的不同的数据库。<br>4.测试一个基于微服务架构的应用很复杂。<br>5.微服务架构模式应用的改变将会波及多个服务。<br>6.部署一个微服务应用也很复杂，一个分布式应用只需要简单在复杂均衡器后面部署各自的服务器就好了。每个应用实例是需要配置诸如数据库和消息中间件等基础服务。</p>
<h3 id="微服务的特征"><a href="#微服务的特征" class="headerlink" title="微服务的特征:"></a>微服务的特征:</h3><p>通过服务实现组件化<br>按业务能力来划分服务于组织团队<br>服务即产品<br>智能终端与哑管道<br>去中心统一化<br>基础设施自动化<br>Design for failure<br>进化设计</p>
<h3 id="微服务总结"><a href="#微服务总结" class="headerlink" title="微服务总结"></a>微服务总结</h3><p>一个微服务一般完成某个特定的功能,每个微服务都是一个微型应用,有着自己的六边形架构,包括商业逻辑和各种接口。<br>有的微服务通过暴露API被别的微服务或者应用客户端所用;有的微服务则通过UI实现。在运行时,每个实力通常时一个云虚拟机或者Docker容器。</p>
<h2 id="SOA、微服务、服务化这几个概念的差别和关系"><a href="#SOA、微服务、服务化这几个概念的差别和关系" class="headerlink" title="SOA、微服务、服务化这几个概念的差别和关系"></a>SOA、微服务、服务化这几个概念的差别和关系</h2><p>SOA服务导向架构，将应用程序功能作为服务发送给最终用户或者其他服务，是整合各种业务的应用程序。<br>微服务是一种以业务功能为主的服务设计，通过将功能分散到各个离散的服务中以实现对解决方案的解耦，所以每一个服务都具有自主运行的业务功能。微服务只属于一个应用程序，它要求业务系统彻底的组件化和服务化。<br>服务化是一种粗粒度、松耦合的以服务为中心的架构，服务之间通过定义明确的协议和接口进行通信。</p>
<h2 id="好的架构应该具备的特征"><a href="#好的架构应该具备的特征" class="headerlink" title="好的架构应该具备的特征"></a>好的架构应该具备的特征</h2><p>基于资源的接口设计<br>开发团队结构要正确映射系统架构<br>要考虑业务架构和组织架构</p>
<p>参考文章:<br><a href="http://colobu.com/2015/04/08/software-architecture-patterns/" target="_blank" rel="external">软件架构模式</a><br><a href="https://www.zhihu.com/question/37808426" target="_blank" rel="external">SOA和微服务的区别</a><br><a href="http://dockone.io/article/394" target="_blank" rel="external">微服务架构的优势与不足</a><br><a href="https://www.ibm.com/developerworks/community/blogs/3302cc3b-074e-44da-90b1-5055f1dc0d9c/entry/%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84_%E4%B8%80_%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1?lang=en" target="_blank" rel="external">解析微服务架构(一)</a><br><a href="http://www.jianshu.com/p/546ef242b6a3" target="_blank" rel="external">基于微服务的软件架构模式</a><br><a href="http://www.hollischuang.com/archives/1628" target="_blank" rel="external">组件化、模块化、集中式、分布式、服务化、面向服务的架构、微服务架构</a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/10/28/Software-Architecture/" class="archive-article-date">
  	<time datetime="2016-10-28T06:46:47.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-10-28</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/technical/">technical</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-Continuous-Integration" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/25/Continuous-Integration/">持续集成(Continuous Integration)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在工作之前,曾经遇到过这么一个问题,和多个小伙伴一起开发,一个人负责了一大块的功能,最后在每个人完成各自的开发工作以后,集成成一个系统。<br>这真的是很痛苦的一件事情,没有任何的铺垫,一堆冲突,集成后也不知道系统是不是存在bug。<br>然而在真正工作以后,才发现了这些问题的正确打开方式。</p>
<h2 id="持续集成是什么"><a href="#持续集成是什么" class="headerlink" title="持续集成是什么"></a>持续集成是什么</h2><p>Martin Fowler对持续集成(Continuous Integration)的定义:</p>
<blockquote>
<p>Continuous Integration is a software development practice where members of a team integrate their work frequently, usually each person integrates at least daily - leading to multiple integrations per day. Each integration is verified by an automated build (including test) to detect integration errors as quickly as possible.Many teams find that this approach leads to significantly reduced integration problems and allows a team to develop cohesive software more rapidly.  </p>
</blockquote>
<p>持续集成是一种软件开发实践，即团队开发成员经常集成他们的工作，通常每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试)来验证，从而尽快地发现集成错误。许多团队发现这个过程可以大大减少集成的问题，让团队能够更快的开发内聚的软件。</p>
<p>Martin Fowler对持续集成的内容概述:</p>
<blockquote>
<p>Maintain a Single Source Repository.<br>  Automate the Build<br>  Make Your Build Self-Testing<br>  Everyone Commits To the Mainline Every Day<br>  Every Commit Should Build the Mainline on an Integration Machine<br>  Fix Broken Builds Immediately<br>  Keep the Build Fast<br>  Test in a Clone of the Production Environment<br>  Make it Easy for Anyone to Get the Latest Executable<br>  Everyone can see what’s happening<br>  Automate Deployment</p>
</blockquote>
<p>  1.统一的代码库。一个团队在开发过程中都需要一个代码库,每个人写的代码都更新到同一个代码库上。例如Github,Gitlab等,如此一来就需要版本管理工具例如git,svn等等。<br>  2.自动构建。手动构建的代价太大,使用工具来自动构建。<br>  3.自动测试。<br>  4.每个人每天都要向代码库主干提交代码。<br>  5.每次代码递交后都会在持续集成服务器上触发一次构建。<br>  6.保证快速构建。<br>  7.模拟生产环境的自动测试。<br>  8.每个人都可以很容易的获取最新可执行的应用程序。<br>  9.每个人都清楚正在发生的状况。<br>  10.自动化的部署。</p>
<h2 id="持续集成的好处"><a href="#持续集成的好处" class="headerlink" title="持续集成的好处"></a>持续集成的好处</h2><p>由上可知,持续集成的好处在于:<br>    (1)快速发现错误。每个coder完成了一小段代码就更新集成到主干,如此一来可以快速的发现错误,并且定位错误,改正错误。<br>    (2)使得代码不会大幅度的偏离主干。如果不经常集成代码,更新不快,最后集成的难度非常大。<br>    (3)在任何时间、任何地点生成可部署的软件。对于客户来说,这便于持续交付。<br>    (4)改善对进度的控制。每天都在集成，就可以看到当前各个功能的进度。<br>    (5)更加充分地测试系统中的各个单元。<br>    (6)与其它工具结合的持续代码质量改进。如使用CheckStyle, PMD, FindBugs, Fxcop等。<br>    (7)便于Code Review。在每个build里，我们都可以知道与前一个build之间有什么改动，然后针对这些改动，我们就可以实施Code Review了。<br>    (8)便于开发流程的管理。比如说，要把一个开发的build提交给测试组作测试，测完满意了，再提交到发布组去发布。</p>
<p> 持续集成的目的，就是让产品可以保持高质量的快速迭代。</p>
<h2 id="持续集成的工具"><a href="#持续集成的工具" class="headerlink" title="持续集成的工具"></a>持续集成的工具</h2><p>CI工具实现了每个开发人员提交代码的时候自动进行构建，包括代码审查、编译、测试、打包等操作。如此可以保证每次提交都是安全的。<br>CI工具还可以提供事件通知,生成报告等。例如当某一步构建失败了发送通知给指定的email、通过特定的设置发出声音等。<br>常见的工具有:<br><a href="https://jenkins.io/index.html" target="_blank" rel="external">Jenkins</a><br><a href="https://www.go.cd/" target="_blank" rel="external">Go</a><br><a href="http://buildbot.net/" target="_blank" rel="external">Buildbot</a></p>
<h2 id="持续集成的规则："><a href="#持续集成的规则：" class="headerlink" title="持续集成的规则："></a>持续集成的规则：</h2><p>  总结规则如下:<br>1）经常提交代码<br>2）不要提交无法构建的代码<br>3）构建失败时，立即修复<br>4）写自动化测试<br>5）必须通过所有测试和代码审查<br>6）执行私有构建<br>7）避免迁出无法构建的代码</p>
<p>遵循以上规则是为了提高CI持续集成成功率，及时修复build</p>
<p>参考文献:<br><a href="http://martinfowler.com/articles/continuousIntegration.html" target="_blank" rel="external">Martin Fowler的Continuous Integration</a><br><a href="http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html" target="_blank" rel="external">持续集成是什么？</a><br><a href="http://www.cnblogs.com/huang0925/p/3333484.html" target="_blank" rel="external">让你的CI跑起来</a><br><a href="http://holbrook.github.io/2014/03/04/ci_tools.html" target="_blank" rel="external">持续集成工具的作用</a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/10/25/Continuous-Integration/" class="archive-article-date">
  	<time datetime="2016-10-25T03:33:21.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-10-25</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CI/">CI</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/technical/">technical</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-Docker-Learn" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/11/Docker-Learn/">Docker 学习笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>自学笔记(一)<br>因为接下来的项目需求,所以需要好好学习一下怎么使用Docker。<br>因为之前没有怎么接触过,所以是从零开始。</p>
<h1 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h1><p><a href="https://docs.docker.com/docker-for-mac/" target="_blank" rel="external">Mac 安装地址</a><br>关于在Ubuntu、CentOS和Debian系统安装Docker,<a href="https://www.gitbook.com/book/yeasy/docker_practice/details" target="_blank" rel="external">Docker —— 从入门到实践</a>书里有安装教程<br>其他系统安装Docker,参考<a href="https://docs.docker.com/engine/installation/" target="_blank" rel="external">官网</a></p>
<h1 id="Docker-三大组件"><a href="#Docker-三大组件" class="headerlink" title="Docker 三大组件"></a>Docker 三大组件</h1><p>仓库<br>镜像<br>容器</p>
<h1 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h1><p>Docker 官方维护了一个公共仓库<a href="https://hub.docker.com/" target="_blank" rel="external">Docker Hub</a></p>
<h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p>本地命令:docker login<br>会有提示输入用户名和密码,一次登录后,会记住登录信息。本地用户目录的 .dockercfg 中将保存用户的认证信息。</p>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p>命令为docker search 命令来查找官方仓库中的镜像，并利用docker pull 命令来将它下载到本地。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker search centos -s 3</div></pre></td></tr></table></figure></p>
<p>-s N(仅显示评价为 N 星以上的镜像)<br>下载命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker pull centos</div></pre></td></tr></table></figure></p>
<h2 id="私有仓库配置"><a href="#私有仓库配置" class="headerlink" title="私有仓库配置"></a>私有仓库配置</h2><p>参考书籍<a href="https://www.gitbook.com/book/yeasy/docker_practice/details" target="_blank" rel="external">Docker —— 从入门到实践</a></p>
<h1 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h1><h2 id="Docker-镜像分层"><a href="#Docker-镜像分层" class="headerlink" title="Docker 镜像分层"></a>Docker 镜像分层</h2><p>有3层,分别为:<br>  基础镜像<br>  中间件镜像<br>  应用镜像</p>
<h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker pull 镜像版本</div></pre></td></tr></table></figure>
<p>将从 Docker Hub 仓库下载一个符合要求的镜像<br>完整的命令为:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker pull registry.hub.docker.com/ubuntu:12.04</div></pre></td></tr></table></figure></p>
<p>即从注册服务器registry.hub.docker.com 中的 ubuntu 仓库来下载标记为 12.04 的镜像。</p>
<h2 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h2><p>下载镜像完成后，可以使用该镜像了，摘自书中的例子:创建一个容器，让其中运行 bash 应用。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker run -t -i ubuntu:12.04 /bin/bash</div></pre></td></tr></table></figure></p>
<h4 id="显示本地已有的镜像"><a href="#显示本地已有的镜像" class="headerlink" title="显示本地已有的镜像"></a>显示本地已有的镜像</h4><p>命令:docker images </p>
<h4 id="修改镜像"><a href="#修改镜像" class="headerlink" title="修改镜像:"></a>修改镜像:</h4><p><strong>1.docker commit 来扩展一个镜像</strong><br>镜像启动容器:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker run -t -i ubuntu:12.04 /bin/bash</div></pre></td></tr></table></figure></p>
<p> -t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， -i 则让容器的标准输入保持打开</p>
<p>在容器中添加json package:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">root@0b2616b0e5a8:/# gem install json</div></pre></td></tr></table></figure></p>
<p>退出: exit<br>提交更新后的副本:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo docker commit -m &quot;Added json gem&quot; -a &quot;Docker Newbee&quot; 0b2616b0e5a8 ouruser/sinatra:v2</div></pre></td></tr></table></figure></p>
<p>ouruser/sinatra:v2为目标镜像的仓库名和 tag 信息,如v2<br></p>
<p><strong>2.docker build 来创建一个新的镜像</strong><br>新建一个文件Dockerfile,里面的每一条指令都创建镜像的一层。<br></p>
<p>Dockerfile 基本的语法是:<br>    使用 # 来注释<br>    FROM 指令告诉 Docker 使用哪个镜像作为基础<br>    接着是维护者的信息<br>    RUN 开头的指令会在创建中运行，比如安装一个软件包，在这里使用 apt-get来安装了一些软件<br></p>
<p>编写完成 Dockerfile 后可以使用 docker build 来生成镜像。例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker build -t=&quot;ouruser/sinatra:v2&quot; .</div></pre></td></tr></table></figure></p>
<p>其中 -t 标记来添加 tag，指定新的镜像的用户信息。 “.” 是 Dockerfile 所在的路径（当前目录），也可以替换为一个具体的 Dockerfile 的路径。</p>
<p>改变镜像标签内容:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker tag 5db5f8471261 ouruser/sinatra:devel #5db...是镜像ID  后面的是修改后的标签</div></pre></td></tr></table></figure></p>
<h4 id="本地导入镜像"><a href="#本地导入镜像" class="headerlink" title="本地导入镜像:"></a>本地导入镜像:</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo cat ubuntu-14.04-x86_64-minimal.tar.gz |docker import - ubuntu:14.04</div></pre></td></tr></table></figure>
<h4 id="镜像上传到远程仓库"><a href="#镜像上传到远程仓库" class="headerlink" title="镜像上传到远程仓库:"></a>镜像上传到远程仓库:</h4><p>Docker Hub 上完成注册后，可以推送自己的镜像到仓库中<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker push ouruser/sinatra</div></pre></td></tr></table></figure></p>
<h4 id="保存镜像到本地文件"><a href="#保存镜像到本地文件" class="headerlink" title="保存镜像到本地文件:"></a>保存镜像到本地文件:</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker save -o ubuntu_14.04.tar ubuntu:14.04</div></pre></td></tr></table></figure>
<h4 id="从导出的本地文件中再加载到本地镜像库"><a href="#从导出的本地文件中再加载到本地镜像库" class="headerlink" title="从导出的本地文件中再加载到本地镜像库:"></a>从导出的本地文件中再加载到本地镜像库:</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ sudo docker load --input ubuntu_14.04.tar</div><div class="line">或</div><div class="line">$ sudo docker load &lt; ubuntu_14.04.tar</div></pre></td></tr></table></figure>
<h4 id="移除镜像"><a href="#移除镜像" class="headerlink" title="移除镜像"></a>移除镜像</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rmi training/sinatra</div></pre></td></tr></table></figure>
<p>在删除镜像之前要先用 docker rm 删掉依赖于这个镜像的所有容器。</p>
<p>清理所有未打过标签的本地镜像<br>$ sudo docker rmi $(docker images -q -f “dangling=true”)<br>sudo docker rmi $(docker images –quiet –filter “dangling=true”)</p>
<h1 id="Docker-容器"><a href="#Docker-容器" class="headerlink" title="Docker 容器"></a>Docker 容器</h1><p>容器是独立运行的一个或一组应用，以及它们的运行态环境。</p>
<h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><p>有两种方式:<br>1.基于镜像新建一个容器并启动<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker run -t -i ubuntu:12.04 /bin/bash</div></pre></td></tr></table></figure></p>
<p>使用docker run 来创建容器时，Docker 在后台运行的标准操作包括：</p>
<ul>
<li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li>
<li>利用镜像创建并启动一个容器</li>
<li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li>
<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>
<li>从地址池配置一个 ip 地址给容器</li>
<li>执行用户指定的应用程序</li>
<li>执行完毕后容器被终止</li>
</ul>
<p>2.将在终止状态（stopped）的容器重新启动<br>docker start命令，直接将一个已经终止的容器启动运行。可以利用 ps 或 top 来查看当前的进程信息。</p>
<h2 id="查看容器信息"><a href="#查看容器信息" class="headerlink" title="查看容器信息"></a>查看容器信息</h2><p>命令:docker ps<br>可以查看所有的容器及进程</p>
<h2 id="容器在后台运行"><a href="#容器在后台运行" class="headerlink" title="容器在后台运行"></a>容器在后台运行</h2><p>普通的docker run命令会在当前宿主机输出结果。<br>加上-d,此时容器会在后台运行并不会把输出的结果打印到宿主机上面,而是返回一个ID。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo docker run -d ubuntu:14.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</div></pre></td></tr></table></figure>
<p>查看输出结果可以用docker logs<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker logs [container ID or NAMES]</div></pre></td></tr></table></figure></p>
<p>里面可以是刚刚返回的ID也可以是NAME</p>
<h2 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h2><p>使用命令docker stop ID来终止</p>
<p>当Docker容器中指定的应用终结时，容器也自动终止。所以之前通过 exit 命令或 Ctrl+d 来退出终端时，所创建的容器立刻终止。<br>查看终止状态的容器可以用 docker ps -a命令。</p>
<h4 id="重启已经终止的容器"><a href="#重启已经终止的容器" class="headerlink" title="重启已经终止的容器"></a>重启已经终止的容器</h4><p>处于终止状态的容器，可以通过 docker start 命令来重新启动。<br>docker restart 命令会将一个运行态的容器终止，然后再重新启动它。</p>
<h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><p>当容器进入后台时,需要进入容器的操作<br>使用Attach命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker run -idt ubuntu <span class="comment">#后台运行</span></div><div class="line">docker ps <span class="comment">#查看进程</span></div><div class="line">docker attach 容器名或者ID</div></pre></td></tr></table></figure></p>
<p>使用nsenter 命令<br>nsenter工具在 util-linux 包2.23版本后包含,设备上没有的,需要手动安装。<br>详细步骤参考书籍<a href="https://www.gitbook.com/book/yeasy/docker_practice/details" target="_blank" rel="external">Docker —— 从入门到实践</a></p>
<h2 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h2><p>导出本地某个容器，使用 docker export 命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker export 容器ID &gt; ubuntu.tar(文件名)</div></pre></td></tr></table></figure></p>
<h2 id="导入容器"><a href="#导入容器" class="headerlink" title="导入容器"></a>导入容器</h2><p>使用docker import从容器快照文件中再导入为镜像:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ cat ubuntu.tar | docker import - <span class="built_in">test</span>/ubuntu:v1.0(镜像名和标签)</div><div class="line">$ docker images <span class="comment">#查看结果</span></div></pre></td></tr></table></figure></p>
<p>或者通过指定 URL 或者某个目录来导入，例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$sudo docker import http://example.com/exampleimage.tgz example/imagerepo</div></pre></td></tr></table></figure></p>
<p><strong>用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，<br>也可以使用 docker import 来导入一个容器快照到本地镜像库。<br>这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。<br>此外，从容器快照文件导入时可以重新指定标签等元数据信息。</strong></p>
<h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><p>使用 docker rm 来删除一个处于终止状态的容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$sudo docker rm trusting_newton</div></pre></td></tr></table></figure></p>
<p>如果要删除一个运行中的容器，可以添加 -f 参数。<br>清理所有处于终止状态的容器,使用以下命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rm $(docker ps -a -q)</div></pre></td></tr></table></figure></p>
<p>书籍:<br><a href="https://www.gitbook.com/book/yeasy/docker_practice/details" target="_blank" rel="external">Docker —— 从入门到实践</a>此处有电子书的下载途径</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/10/11/Docker-Learn/" class="archive-article-date">
  	<time datetime="2016-10-11T08:25:20.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-10-11</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Docker/">Docker</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/technical/">technical</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-markdown" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/09/markdown/">使用Markdown编辑器写博客</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本博客非原创,,转自CSDN官方编辑器提示,用来帮组小伙伴使用markdown写博客</p>
<p>正文如下:</p>
<p>本Markdown编辑器使用<a href="https://github.com/benweet/stackedit" target="_blank" rel="external">StackEdit</a>修改而来，用它写博客，将会带来全新的体验哦：</p>
<ul>
<li><strong>Markdown和扩展Markdown简洁的语法</strong></li>
<li><strong>代码块高亮</strong></li>
<li><strong>图片链接和图片上传</strong></li>
<li><strong><em>LaTex</em>数学公式</strong></li>
<li><strong>UML序列图和流程图</strong></li>
<li><strong>离线写博客</strong></li>
<li><strong>导入导出Markdown文件</strong></li>
<li><strong>丰富的快捷键</strong></li>
</ul>
<hr>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul>
<li>加粗    <code>Ctrl + B</code></li>
<li>斜体    <code>Ctrl + I</code></li>
<li>引用    <code>Ctrl + Q</code></li>
<li>插入链接    <code>Ctrl + L</code></li>
<li>插入代码    <code>Ctrl + K</code></li>
<li>插入图片    <code>Ctrl + G</code></li>
<li>提升标题    <code>Ctrl + H</code></li>
<li>有序列表    <code>Ctrl + O</code></li>
<li>无序列表    <code>Ctrl + U</code></li>
<li>横线    <code>Ctrl + R</code></li>
<li>撤销    <code>Ctrl + Z</code></li>
<li>重做    <code>Ctrl + Y</code></li>
</ul>
<h2 id="Markdown及扩展"><a href="#Markdown及扩展" class="headerlink" title="Markdown及扩展"></a>Markdown及扩展</h2><blockquote>
<p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。    —— <a href="https://zh.wikipedia.org/wiki/Markdown" target="_blank"> [ 维基百科 ]</a></p>
</blockquote>
<p>使用简单的符号标识不同的标题，将某些文字标记为<strong>粗体</strong>或者<em>斜体</em>，创建一个<a href="http://www.csdn.net" target="_blank" rel="external">链接</a>等，详细语法参考帮助？。</p>
<p>本编辑器支持 <strong>Markdown Extra</strong> , 　扩展了很多好用的功能。具体请参考<a href="https://github.com/jmcmanus/pagedown-extra" title="Pagedown Extra" target="_blank" rel="external">Github</a>.</p>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p><strong>Markdown　Extra</strong>　表格语法：</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>价格</th>
</tr>
</thead>
<tbody>
<tr>
<td>Computer</td>
<td>$1600</td>
</tr>
<tr>
<td>Phone</td>
<td>$12</td>
</tr>
<tr>
<td>Pipe</td>
<td>$1</td>
</tr>
</tbody>
</table>
<p>可以使用冒号来定义对齐方式：</p>
<table>
<thead>
<tr>
<th style="text-align:left">项目</th>
<th style="text-align:right">价格</th>
<th style="text-align:center">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Computer</td>
<td style="text-align:right">1600 元</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:left">Phone</td>
<td style="text-align:right">12 元</td>
<td style="text-align:center">12</td>
</tr>
<tr>
<td style="text-align:left">Pipe</td>
<td style="text-align:right">1 元</td>
<td style="text-align:center">234</td>
</tr>
</tbody>
</table>
<h3 id="定义列表"><a href="#定义列表" class="headerlink" title="定义列表"></a>定义列表</h3><p><strong>Markdown　Extra</strong>　定义列表语法：<br>项目１<br>项目２<br>:   定义 A<br>:   定义 B</p>
<p>项目３<br>:   定义 C</p>
<p>:   定义 D</p>
<pre><code>&gt; 定义D内容
</code></pre><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>代码块语法遵循标准markdown代码，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@requires_authorization</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">somefunc</span><span class="params">(param1=<span class="string">''</span>, param2=<span class="number">0</span>)</span>:</span></div><div class="line">    <span class="string">'''A docstring'''</span></div><div class="line">    <span class="keyword">if</span> param1 &gt; param2: <span class="comment"># interesting</span></div><div class="line">        <span class="keyword">print</span> <span class="string">'Greater'</span></div><div class="line">    <span class="keyword">return</span> (param2 - param1 + <span class="number">1</span>) <span class="keyword">or</span> <span class="keyword">None</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>message = <span class="string">'''interpreter</span></div><div class="line"><span class="meta">... </span>prompt'''</div></pre></td></tr></table></figure></p>
<h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><p>生成一个脚注[^footnote].<br>  [^footnote]: 这里是 <strong>脚注</strong> 的 <em>内容</em>.</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>用 <code>[TOC]</code>来生成目录：</p>
<p>[TOC]</p>
<h3 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h3><p>使用MathJax渲染<em>LaTex</em> 数学公式，详见<a href="http://math.stackexchange.com/" target="_blank" rel="external">math.stackexchange.com</a>.</p>
<ul>
<li>行内公式，数学公式为：$\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$。</li>
<li>块级公式：</li>
</ul>
<p>$$    x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$</p>
<p>更多LaTex语法请参考 <a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="external">这儿</a>.</p>
<h3 id="UML-图"><a href="#UML-图" class="headerlink" title="UML 图:"></a>UML 图:</h3><p>可以渲染序列图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">张三-&gt;李四: 嘿，小四儿, 写博客了没?</div><div class="line">Note right of 李四: 李四愣了一下，说：</div><div class="line">李四--&gt;张三: 忙得吐血，哪有时间写。</div></pre></td></tr></table></figure>
<p>或者流程图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">st=&gt;start: 开始</div><div class="line">e=&gt;end: 结束</div><div class="line">op=&gt;operation: 我的操作</div><div class="line">cond=&gt;condition: 确认？</div><div class="line"></div><div class="line">st-&gt;op-&gt;cond</div><div class="line">cond(yes)-&gt;e</div><div class="line">cond(no)-&gt;op</div></pre></td></tr></table></figure>
<ul>
<li>关于 <strong>序列图</strong> 语法，参考 <a href="http://bramp.github.io/js-sequence-diagrams/" target="_blank" rel="external">这儿</a>,</li>
<li>关于 <strong>流程图</strong> 语法，参考 <a href="http://adrai.github.io/flowchart.js/" target="_blank" rel="external">这儿</a>.</li>
</ul>
<h2 id="离线写博客"><a href="#离线写博客" class="headerlink" title="离线写博客"></a>离线写博客</h2><p>即使用户在没有网络的情况下，也可以通过本编辑器离线写博客（直接在曾经使用过的浏览器中输入<a href="http://write.blog.csdn.net/mdeditor" target="_blank" rel="external">write.blog.csdn.net/mdeditor</a>即可。<strong>Markdown编辑器</strong>使用浏览器离线存储将内容保存在本地。</p>
<p>用户写博客的过程中，内容实时保存在浏览器缓存中，在用户关闭浏览器或者其它异常情况下，内容不会丢失。用户再次打开浏览器时，会显示上次用户正在编辑的没有发表的内容。</p>
<p>博客发表后，本地缓存将被删除。　</p>
<p>用户可以选择 <i class="icon-disk"></i> 把正在写的博客保存到服务器草稿箱，即使换浏览器或者清除缓存，内容也不会丢失。</p>
<blockquote>
<p><strong>注意：</strong>虽然浏览器存储大部分时候都比较可靠，但为了您的数据安全，在联网后，<strong>请务必及时发表或者保存到服务器草稿箱</strong>。</p>
</blockquote>
<h2 id="浏览器兼容"><a href="#浏览器兼容" class="headerlink" title="浏览器兼容"></a>浏览器兼容</h2><ol>
<li>目前，本编辑器对Chrome浏览器支持最为完整。建议大家使用较新版本的Chrome。</li>
<li>IE９以下不支持</li>
<li>IE９，１０，１１存在以下问题<ol>
<li>不支持离线功能</li>
<li>IE9不支持文件导入导出</li>
<li>IE10不支持拖拽文件导入</li>
</ol>
</li>
</ol>
<hr>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/10/09/markdown/" class="archive-article-date">
  	<time datetime="2016-10-09T01:33:08.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-10-09</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/technical/">technical</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-Angular-Filter" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/08/Angular-Filter/">Angular Order And Filter</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>angular 排序可以使用orderBy标签,它支持一个排序函数或简单地指定一个属性名进行排序</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># HTML5</span></div><div class="line">&lt;div ng-controller=<span class="string">"TestCtrl"</span>&gt;</div><div class="line">    根据age正排序</div><div class="line">    &#123;&#123; data | orderBy: <span class="string">'age'</span> &#125;&#125; &lt;br/&gt;</div><div class="line">    根据age倒排序</div><div class="line">    &#123;&#123; data | orderBy: <span class="string">'-age'</span> &#125;&#125; &lt;br/&gt;</div><div class="line">    根据age正排序,取前2个</div><div class="line">    &#123;&#123; data | orderBy: <span class="string">'-age'</span> | <span class="built_in">limit</span>To: 2 &#125;&#125; &lt;br/&gt;</div><div class="line">    根据age倒排序,name正排序</div><div class="line">    &#123;&#123; data | orderBy: [<span class="string">'-age'</span>, <span class="string">'name'</span>] &#125;&#125; &lt;br/&gt;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line"><span class="comment"># JS 给data的值</span></div><div class="line"><span class="variable">$scope</span>.data = [&#123;name: <span class="string">'B'</span>, age: 4&#125;,&#123;name: <span class="string">'A'</span>, age: 1&#125;,&#123;name: <span class="string">'D'</span>, age: 3&#125;,&#123;name: <span class="string">'C'</span>, age: 3&#125;];</div></pre></td></tr></table></figure>
<p>{ {orderBy_expression | orderBy : expression : reverse : comparator} }<br>orderBy_expression:数组<br>expression:一个String或者是一个function,用来比较的基准<br>reverse:反转<br>comparator:比较器</p>
<p>可以使用ng-repeat遍历,以表格形式显示<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;tr ng-repeat=<span class="string">"friend in friends | orderBy:['-age', 'name']"</span>&gt;</div><div class="line">    &lt;td&gt;&#123;&#123;friend.name&#125;&#125;&lt;/td&gt;</div><div class="line">    &lt;td&gt;&#123;&#123;friend.phone&#125;&#125;&lt;/td&gt;</div><div class="line">    &lt;td&gt;&#123;&#123;friend.age&#125;&#125;&lt;/td&gt;</div><div class="line">&lt;/tr&gt;</div></pre></td></tr></table></figure></p>
<p>JS里用order<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># JS</span></div><div class="line">angular.module(<span class="string">'orderByExample'</span>, [])</div><div class="line">            .controller(<span class="string">'ExampleController'</span>, [<span class="string">'$scope'</span>,<span class="string">'orderByFilter'</span>, <span class="keyword">function</span>(<span class="variable">$scope</span>, orderBy)  &#123;</div><div class="line">            var friends = [</div><div class="line">                                &#123;name: <span class="string">'John'</span>,   phone: <span class="string">'555-1212'</span>,  age: 10&#125;,</div><div class="line">                                &#123;name: <span class="string">'Mary'</span>,   phone: <span class="string">'555-9876'</span>,  age: 19&#125;,</div><div class="line">                                &#123;name: <span class="string">'Mike'</span>,   phone: <span class="string">'555-4321'</span>,  age: 21&#125;,</div><div class="line">                                &#123;name: <span class="string">'Adam'</span>,   phone: <span class="string">'555-5678'</span>,  age: 35&#125;,</div><div class="line">                                &#123;name: <span class="string">'Julie'</span>,  phone: <span class="string">'555-8765'</span>,  age: 29&#125;</div><div class="line">                            ];</div><div class="line">            <span class="variable">$scope</span>.friends = orderBy(friends, <span class="string">'age'</span>, <span class="variable">$scope</span>.reverse);</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line"><span class="comment"># HTML5</span></div><div class="line">&lt;tr ng-repeat=<span class="string">"friend in friends"</span>&gt;</div></pre></td></tr></table></figure></p>
<p>类似自定义的比较function即comparator等<br>更多内容见<a href="https://docs.angularjs.org/api/ng/filter/orderBy" target="_blank" rel="external">Angular官方文档</a></p>
<h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2><p>可以非常方便的对表格进行过滤<br>格式如下:<br>{ { filter_expression | filter : expression : comparator : anyPropertyKey} }<br>使用方法:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;&#123; friends | filter: <span class="string">'J'</span> &#125;&#125;</div></pre></td></tr></table></figure></p>
<p>即对friends数组进行过滤,找到里面包含J字样的所有值。</p>
<p>使用表格:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;label&gt;Search: &lt;input ng-model=<span class="string">"searchText"</span>&gt;&lt;/label&gt;</div><div class="line">&lt;table id=<span class="string">"searchTextResults"</span>&gt;</div><div class="line">  &lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Phone&lt;/th&gt;&lt;/tr&gt;</div><div class="line">  &lt;tr ng-repeat=<span class="string">"friend in friends | filter:searchText"</span>&gt;</div><div class="line">    &lt;td&gt;&#123;&#123;friend.name&#125;&#125;&lt;/td&gt;</div><div class="line">    &lt;td&gt;&#123;&#123;friend.phone&#125;&#125;&lt;/td&gt;</div><div class="line">  &lt;/tr&gt;</div><div class="line">&lt;/table&gt;</div></pre></td></tr></table></figure></p>
<p>即根据输入框的值searchText过滤friends数组的内容,并且以表格的形式显示。</p>
<p>更多过滤条件:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;label&gt;Any: &lt;input ng-model=<span class="string">"search.$"</span>&gt;&lt;/label&gt; &lt;br&gt;</div><div class="line">&lt;label&gt;Name only &lt;input ng-model=<span class="string">"search.name"</span>&gt;&lt;/label&gt;&lt;br&gt;</div><div class="line">&lt;label&gt;Phone only &lt;input ng-model=<span class="string">"search.phone"</span>&gt;&lt;/label&gt;&lt;br&gt;</div><div class="line">&lt;label&gt;Equality &lt;input <span class="built_in">type</span>=<span class="string">"checkbox"</span> ng-model=<span class="string">"strict"</span>&gt;&lt;/label&gt;&lt;br&gt;</div><div class="line">&lt;table id=<span class="string">"searchObjResults"</span>&gt;</div><div class="line">    &lt;tr&gt;</div><div class="line">        &lt;th&gt;Name&lt;/th&gt;</div><div class="line">        &lt;th&gt;Phone&lt;/th&gt;</div><div class="line">    &lt;/tr&gt;</div><div class="line">    &lt;tr ng-repeat=<span class="string">"friendObj in friends | filter:search:strict"</span>&gt;</div><div class="line">        &lt;td&gt;&#123;&#123;friendObj.name&#125;&#125;&lt;/td&gt;</div><div class="line">        &lt;td&gt;&#123;&#123;friendObj.phone&#125;&#125;&lt;/td&gt;</div><div class="line">    &lt;/tr&gt;</div><div class="line">&lt;/table&gt;</div></pre></td></tr></table></figure></p>
<p>strict表示严格筛选,只有字段与搜索内容完全一致才显示。<br>search是筛选条件,这里可以全部一起筛选,或者只根据姓名或者电话进行筛选。</p>
<p>筛选条件不仅可以是字段名,还可以是自定义的函数<br>使用方法:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># HTML5</span></div><div class="line">使用函数过滤,年龄大与19的:&#123;&#123; friends | filter: f &#125;&#125; &lt;br /&gt;</div><div class="line"><span class="comment"># JS</span></div><div class="line"><span class="variable">$scope</span>.f = <span class="keyword">function</span>(e)&#123;</div><div class="line">    <span class="built_in">return</span> e.age &gt; 19;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>更多filter内容见<a href="https://docs.angularjs.org/api/ng/filter" target="_blank" rel="external">angular官方文档</a></p>
<p>例子代码:<br><a href="https://github.com/wszhi/font_end/blob/master/src/com/angular/example/8_filter.html" target="_blank" rel="external">Github简单例子</a><br><a href="https://github.com/wszhi/font_end/blob/master/src/com/angular/example/8.1_big_example_for_order_by_column.html" target="_blank" rel="external">Github OrderBy例子</a><br><a href="https://github.com/wszhi/font_end/blob/master/src/com/angular/example/8.2_big_example_for_filter.html" target="_blank" rel="external">Github filter例子</a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/10/08/Angular-Filter/" class="archive-article-date">
  	<time datetime="2016-10-08T08:15:32.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-10-08</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Angular/">Angular</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/technical/">technical</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-Angular-Form-Input-Type" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/08/Angular-Form-Input-Type/">Angular Form Input Type</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Form 表单中有很多元素,最普遍的Input,CheckBox,Radio,Select等等。Angular的Form有什么特殊之处呢?</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>Input的属性有:<br>    name 名字<br>    type 类型(HTML5里有的类型: number,url,email)<br>    ng-model 绑定的数据<br>    required/ng-required 是否必填<br>    ng-minlength 最小长度<br>    ng-maxlength 最大长度<br>    ng-pattern 匹配模式<br>    ng-change 值变化时的回调</p>
<p>例子(输入长度5-15的起始为abc的内容):<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;input <span class="built_in">type</span>=<span class="string">"text"</span> name=<span class="string">"a"</span> required ng-model=<span class="string">"a"</span> required ng-minlength=5 ng-maxlength=15 ng-pattern=<span class="string">"/abc/"</span>/&gt;</div></pre></td></tr></table></figure></p>
<h3 id="Checkbox"><a href="#Checkbox" class="headerlink" title="Checkbox"></a>Checkbox</h3><p>Checkbox只有两种值,选中和不选中。</p>
<p>使用方法:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># HTML5:</span></div><div class="line"></div><div class="line"> &lt;input <span class="built_in">type</span>=<span class="string">"checkbox"</span> name=<span class="string">"checkbox"</span> ng-model=<span class="string">"checkbox_value"</span> ng-true-value=<span class="string">"AA"</span> ng-false-value=<span class="string">"BB"</span>/&gt;</div><div class="line"> &lt;span&gt;&#123;&#123; checkbox_value &#125;&#125;&lt;/span&gt;</div><div class="line"></div><div class="line"><span class="comment"># JS:</span></div><div class="line"> <span class="variable">$scope</span>.checkbox_value = <span class="string">'AA'</span>; <span class="comment">#controller中的初始化值会关系到控件状态（双向绑定）</span></div></pre></td></tr></table></figure></p>
<h3 id="Radio"><a href="#Radio" class="headerlink" title="Radio"></a>Radio</h3><p>与checkbox的区别,一个radio只有一个值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;input <span class="built_in">type</span>=<span class="string">"radio"</span> name=<span class="string">"radio_test"</span> ng-model=<span class="string">"radio_test"</span> value=<span class="string">"AA"</span>/&gt;AA</div><div class="line">&lt;input <span class="built_in">type</span>=<span class="string">"radio"</span> name=<span class="string">"radio_test"</span> ng-model=<span class="string">"radio_test"</span> value=<span class="string">"BB"</span>/&gt;BB&lt;br&gt;</div><div class="line">radio选中的值为:&lt;span&gt;&#123;&#123; radio_test &#125;&#125;&lt;/span&gt;</div></pre></td></tr></table></figure>
<h3 id="Textarea"><a href="#Textarea" class="headerlink" title="Textarea"></a>Textarea</h3><p>与Input类似,但是可以拉伸</p>
<h3 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h3><p>使用ng-options遍历数组</p>
<p>x for x in 数组名(普通数组)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;div ng-init=<span class="string">"o=[0,1,2,3]; a=o[1];"</span>&gt;</div><div class="line">    &lt;select ng-model=<span class="string">"select_test"</span> ng-options=<span class="string">"x for x in o"</span> ng-change=<span class="string">"show()"</span>&gt;</div><div class="line">        &lt;option value=<span class="string">""</span>&gt;可以加这个空值&lt;/option&gt;</div><div class="line">    &lt;/select&gt;select选中的值为: &#123;&#123; select_test &#125;&#125;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>x.name for x in 数组名(对象数组,有key,value)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;div ng-init=<span class="string">"o2=[&#123;name: 'AA'&#125;, &#123;name: 'BB'&#125;]; a=o2[1];"</span>&gt;</div><div class="line">    &lt;select ng-model=<span class="string">"select_test2"</span> ng-options=<span class="string">"x.name for x in o2"</span>&gt;</div><div class="line">    &lt;/select&gt;select选中的值为: &#123;&#123; select_test2 &#125;&#125;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>x.v as x.name for x in 数组名(选择框显示的是name的值,但选中的value值是v的值)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;div ng-init=<span class="string">"o3=[&#123;name: 'AA', v: '00'&#125;, &#123;name: 'BB', v: '11'&#125;]; a=o3[1].v;"</span>&gt;</div><div class="line">    &lt;select ng-model=<span class="string">"select_test3"</span> ng-options=<span class="string">"x.v as x.name for x in o3"</span>&gt;</div><div class="line">    &lt;/select&gt;select选中的值为: &#123;&#123; select_test3 &#125;&#125;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>x.name group by x.g for x in 数组名(根据g的值来分组)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;div ng-init=<span class="string">"o4=[&#123;name: 'AA', g: '00'&#125;,&#123;name: 'BB', g: '11'&#125;,&#123;name: 'CC', g: '00'&#125;]; select_test4=o4[1];"</span>&gt;</div><div class="line">    &lt;select ng-model=<span class="string">"select_test4"</span> ng-options=<span class="string">"x.name group by x.g for x in o4"</span>&gt;</div><div class="line">    &lt;/select&gt;select选中的值为: name值是&#123;&#123; select_test4.name &#125;&#125;;value是&#123;&#123; select_test4.g &#125;&#125;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>x.v as x.name group by x.g for x in 数组名(分组了还分别指定显示与值的,根据g分组,v的值是value值,name值是显示的内容)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;div ng-init=<span class="string">"o5=[&#123;name: 'AA', g: '00', v: '='&#125;, &#123;name: 'BB', g: '11', v: '+'&#125;,&#123;name: 'CC', g: '00', v: '!'&#125;]; select_test5=o5[1].v;"</span>&gt;</div><div class="line">    &lt;select ng-model=<span class="string">"select_test5"</span> ng-options=<span class="string">"x.v as x.name group by x.g for x in o5"</span>&gt;</div><div class="line">    &lt;/select&gt;select选中的值为: &#123;&#123; select_test5 &#125;&#125;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>v.v as v.name group by v.g for (k, v) in 对象名(o6是一个对象,对象中有两个(key:value)对,可以取对象的值来遍历)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;div ng-init=<span class="string">"o6=&#123;a: &#123;name: 'AA', v: '00', g: '=='&#125;,b: &#123;name: 'BB', v: '11', g: '=='&#125;&#125;; select_test6=o6.a.v;"</span>&gt;</div><div class="line">        参数是对象&lt;br&gt;</div><div class="line">        显示对象的值里的v的值&lt;br&gt;</div><div class="line">        &lt;select ng-model=<span class="string">"select_test6"</span> ng-options=<span class="string">"v.v as v.name group by v.g for (k, v) in o6"</span>&gt;</div><div class="line">        &lt;/select&gt;select选中的值为: &#123;&#123; select_test6 &#125;&#125;、</div><div class="line">        显示对象的名字&lt;br&gt;</div><div class="line">        &lt;select ng-model=<span class="string">"select_test7"</span> ng-options=<span class="string">"k for (k, v) in o6"</span>&gt;</div><div class="line">        &lt;/select&gt;select选中的值为: &#123;&#123; select_test7 &#125;&#125;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>Github<a href="https://github.com/wszhi/font_end/blob/master/src/com/angular/example/7.6_form_input_checkbox_ect.html" target="_blank" rel="external">参考代码</a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/10/08/Angular-Form-Input-Type/" class="archive-article-date">
  	<time datetime="2016-10-08T03:21:33.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-10-08</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Angular/">Angular</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/technical/">technical</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  


      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 Shengzhi Wang
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
  本站总访问量 <span id="busuanzi_value_site_pv"></span> 次, 访客数 <span id="busuanzi_value_site_uv"></span> 人次, 本文总阅读量 <span id="busuanzi_value_page_pv"></span> 次

  <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

</footer>

    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/"
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
      <li data-hook="tools-section-friends"><span class="text">友链</span><i class="icon-link"></i></li>
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<a href="/tags/Angular/" style="font-size: 16.67px;">Angular</a> <a href="/tags/CI/" style="font-size: 10px;">CI</a> <a href="/tags/Docker/" style="font-size: 16.67px;">Docker</a> <a href="/tags/Github/" style="font-size: 10px;">Github</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/ansible/" style="font-size: 10px;">ansible</a> <a href="/tags/essays/" style="font-size: 13.33px;">essays</a> <a href="/tags/html5/" style="font-size: 13.33px;">html5</a> <a href="/tags/technical/" style="font-size: 20px;">technical</a>
    			</div>
    	</section>
    

    
    	<section class="tools-section tools-section-friends">
  		
  			<div class="friends-wrap" id="js-friends">
  			
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/wszhi">我的Github</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://blog.csdn.net/u012138931">我的CSDN</a>
  	        
  	        </div>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">靡不有初，&lt;br&gt;&lt;br&gt;鲜克有终。&lt;br&gt;&lt;br&gt;不断努力,一步一步往前走,做最好的自己</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>